#!/bin/csh -fx
#
# CSH module defining functions for fvpsas.
#
# !REVISION HISTORY
#
#  19Nov2006  da Silva  Split from fvpsas.
#  26Dec2006  Todling   Generalized saverst handle; bug fix for no-IAU case.
#  05Jan2007  Stassi    set echo (if $?ECHO___) at front of each Sub
#  05Jan2007  Todling   Added CNOP files reference (merge w/ tlm/adm tag).
#  08Jan2007  dkokron   Add workaround for 'discover' linux cluster
#  18Jan2007  Todling   Added output of fcst sensitivity prog to files to retag
#  01Feb2007  TO/JCS    Moved name of blending executable into env variable
#  22Feb2007  Owens     Modified restart blending to remove rst4ncepf references
#  27Feb2007  Todling   - Removed reference to RUC
#                       - Redefined IAUOSET in minutes
#                       - Generalized handling of bkg files & how they become rst
#  01Mar2007  RL/TO     Added support for /input DMF status checking
#  12Mar2007  Todling   - Renamed IAUOSET to DOIAU
#  1June2007  Kokron    Added zeit calls and mods to support running prepqc while the 
#                       model is still running
#  2Aug2007   Kokron    Call cnv2prs using prund.pl when on discover.  Speedup ~80 min to 4 min
#  13Jul2007  Todling   Add mechanisms to triger cycling 4dvar
#  07Aug2007  Todling   Bypass fvana; calling analyzer directly; add observer
#  13Aug2007  Owens/DK  Optimized bootstrap mode and discover/acquire workaround for
#                       multiple segment runs
#  09Oct2007  Kokron    Call diag2ods using prund.pl when on discover
#  10Oct2007  Kokron    Mods to allow HISTORY to drop the prepqc trigger file
#                       instead of the GCM
#  02Nov2007  Todling   Implemented obs sensitivity capability
#  05Nov2007  Stassi    Use getsponsor utility to get non-"g" GIDs
#  16Nov2007  Todling   Flexible i/o of trajectory during forecast
#  29Nov2007  Todling   Add weak constraint-like option
#  19Dec2007  Owens     Save agcm restart to simplify replays
#  23Jan2008  Owens     Added InterimTag_() function to partition log files during multi-day runs
#  23Mar2008  Todling   Add -ifcst to forecast from offset IAU-initialized state
#  21Apr2008  Owens     Mods to preserve obsys.acq functionality in PreAnalysisQC_()
#                       for multi-day runs and parallelize calls within FixEndian 
#                       and FixUnblock portions of the subroutine
#  23Apr2008  Stassi    Added sub LandAnalysisRun_()
#  23Jun2008  Todling   Fix to skip analysis option
#  17Jul2008  Todling   Removed remap from hdf2rs.x call that updates GCM IC
#  04Mar2009  Todling   Generalized suffix of NC files (add NCSUFFIX env var)
#  12Mar2009  Todling   Add T. Owens' changes from 1/8-degree run
#  19Mar2009  Todling   - Revisited saving of rst during a many-cycle run
#                       - Remove -cprs flag (stage of rst handled via STAGE4FCST)
#                       - Following Owens, add ability to issue fcst straight from DAS
#                       - All short-range fcst with cycle N-seg DAS: specific CAP and HISTORY
#                       - Diag2ODSRun is now called at each analysis time
#  22Jun2009  Kokron    mods to allow scripting to recognize pleiades and call cnv2prs properly
#  24Jun2009  Todling   updated FGAT hooks to comply w/ 3dvar-IAU instead of 4dvar for now
#  27Jul2009  Stassi/TO Sed EXPID in GSI_GridComp.rc.tmpl; remove STRICT requirement
#  01Sep2009  Owens     Save restarts for resumed fcst; eliminate invalid data in tcvitals
#  02Oct2009  Stassi    Correct error in renaming agcm_import_rst
#  13Nov2009  Todling   Various additions/changes/fixes for 4dvar
#  03Dec2009  Todling   - Wired-in freq of obs files (bufr files are what they are)
#                       - Fixes for long-window 4dvar
#  23Sep2010  Todling   - revisit knobs to 4dvar
#  31Sep2010  RT/BZhang - revisit knobs to WC 4dvar
#  10Oct2010  Todling   Add features to allow saving traj during continual DAS forescast
#  15Feb2011  Todling   Add cubed-sphere knobs for DAS
#  22Apr2011  Owens     Support for G5/ECMWF restart blending via the -blendec option
#  09Aug2011  Kokron    - Increase prund.pl process count to reflect added task
#                       - Moved some zeit calls
#                       - Mods to pleiades "else if" to capture nodes with id's larger than r[0-1]*
#  02Dec2011 Todling    - Add RunSplitObserver to allow running 4dvar obsvr outside of GCM
#                       - Add reference to FGAT rc file
#  03Sep2012 Todling    Add IDF; fixes for intermittent replay
#  23Apr2013 Sienkiewicz - bring aircraft bias file from 'recycle'
#  30May2013 Todling    Add GetAODinfo4Fcst to allow fcst to reproduce DAS when AOD is on.
#  24Aug2013 Todling    Allow separete forecast to use bkg06 file to recreate agcm_import when
#                       the latter not available at runtime; acquire fcst.acq nolonger strick.
#  26Feb2014 Sienkiewicz  Modify aircraft bias correction to include options
#                            2 & 3 for NCEP variational bias correction
#  16Sep2015 Todling    - Save RSTs as tar-ball
#                       - add env var RSTSUFFIX to prepare for nc4/bin RSTs opt
#  10May2016 Todling    - Add ability to run TLM using increments from 4d-analysis
#                       - Revise multi-incremental approach for 4d-analysis 
#                         (cost goes down with successive updates)
#                       - Temporarily leaving test lines commented out 
#-----------------------------------------------------------------------------

#
#                            C S H     F U N C T I O N S
#                            ---------------------------


#-----------------------
  Sub Initialize_()
#-----------------------
   if ( $?ECHO___ ) set echo

  set myname = `basename $0`

  echo "HOST = $HOST"
  if (-f /etc/SuSE-release) then
      echo "/etc/SuSE-release"
      cat /etc/SuSE-release
  endif

# Defaults
# --------
  if ( !($?GID) ) then
      echo " GID must be set in job script"
      exit 1
  endif
  if ( !($?ACFTBIAS) )            setenv ACFTBIAS      0
  if ( !($?ANGLEBC) )             setenv ANGLEBC       0
  if ( !($?AGCMFCST)  )           setenv AGCMFCST      0
  if ( !($?AODBLOCKJOB) )         setenv AODBLOCKJOB   0
  if ( !($?AOD_OBSCLASS) )        setenv AOD_OBSCLASS  none
  if ( !($?ASYNBKG)  )            setenv ASYNBKG       360
  if ( !($?BATCH_SUBCMD) )        setenv BATCH_SUBCMD  qsub
  if ( !($?BKG_PREPQC) )          setenv BKG_PREPQC    0
  if ( !($?BOOTSTRAP) )           setenv BOOTSTRAP     0
  if ( !($?CENTRAL_AGCM_PARALLEL) ) setenv CENTRAL_AGCM_PARALLEL 0
  if ( !($?CHECK_DMF) )           setenv CHECK_DMF     1
  if ( !($?CONVPROG) )            setenv CONVPROG      0
  if ( !($?CONVSFC) )             setenv CONVSFC       0
  if ( !($?CONVUPA) )             setenv CONVUPA       0
  if ( !($?DATAMOVE_CONSTRAINT) ) setenv DATAMOVE_CONSTRAINT NULL
  if ( !($?DIAG2ODS) )            setenv DIAG2ODS      0
  if ( !($?DIAGTAR) )             setenv DIAGTAR       0
  if ( !($?DO_0HR_IMP) )          setenv DO_0HR_IMP    0
  if ( !($?DO4DTLM) )             setenv DO4DTLM       0
  if ( !($?DO4DVAR) )             setenv DO4DVAR       0
  if ( !($?DO4DVAROBSVR) )        setenv DO4DVAROBSVR  0
  if ( !($?DOFREPACK) )           setenv DOFREPACK     0
  if ( !($?DOIAU) )               setenv DOIAU         0
  if ( !($?DO4DIAU) )             setenv DO4DIAU       0
  if ( !($?DO_DMGET) )            setenv DO_DMGET      1
  if ( !($?FANA) )                setenv FANA          0
  if ( !($?GAASFDBK ) )           setenv GAASFDBK      0
  if ( !($?GAAS_ANA ) )           setenv GAAS_ANA      0
  if ( !($?GAAS_IGNORE ) )        setenv GAAS_IGNORE   0
  if ( !($?GAAS_RUN_SLURM ) )     setenv GAAS_RUN_SLURM 0
  if ( !($?HREPACK_WAIT) )        setenv HREPACK_WAIT  360
  if ( !($?IGNORE_0) )            setenv IGNORE_0      0
  if ( !($?INITTAG) )             setenv INITTAG       0
  if ( !($?LDAS_ANA) )            setenv LDAS_ANA      0
  if ( !($?LOCAL_ACQUIRE) )       setenv LOCAL_ACQUIRE 0
  if ( !($?MAP05RST) )            setenv MAP05RST      0
  if ( !($?MKRESRST ) )           setenv MKRESRST      0
  if ( !($?MONTHLY_RADMON) )      setenv MONTHLY_RADMON 0
  if ( !($?MPIRUN_IDF) )          setenv MPIRUN_IDF    0
  if ( !($?MPIRUN_UPRST) )        setenv MPIRUN_UPRST  /dev/null
  if ( !($?NEWRADBC) )            setenv NEWRADBC      0
  if ( !($?NCSUFFIX) )            setenv NCSUFFIX      nc4
  if ( !($?NVAROUTER) )           setenv NVAROUTER     1
  if ( !($?PREPQC) )              setenv PREPQC        0
  if ( !($?RADCOR) )              setenv RADCOR        0
  if ( !($?SHORTFCST) )           setenv SHORTFCST     0
  if ( !($?SKIPANA)  )            setenv SKIPANA       0
  if ( !($?SKIP_PSAS)  )          setenv SKIP_PSAS     0
  if ( !($?SPLITEXE) )            setenv SPLITEXE      0
  if ( !($?STRICT) )              setenv STRICT        0
  if ( !($?TIMEINC) )             setenv TIMEINC       360
  if ( !($?USE_ASCAT) )           setenv USE_ASCAT     0
  if ( !($?USE_MODIS_STAGE) )     setenv USE_MODIS_STAGE 0
  if ( !($?VAROFFSET) )           setenv VAROFFSET     180
  if ( !($?VTRACK) )              setenv VTRACK        1
  if ( !($?VTRKFRQA ) )           setenv VTRKFRQA      0
  if ( !($?VTRKFRQF ) )           setenv VTRKFRQF      0
  if ( !($?VTXRELOC ) )           setenv VTXRELOC      1
  if ( !($?WCONSTRAINT) )         setenv WCONSTRAINT   0

  if ( !($?doPLOTS) )             setenv doPLOTS       0
  if ( !($?doFSENS) ) then
      if ( -e stage4fsens.arc ) then
          setenv doFSENS 1
      else
          setenv doFSENS 0
      endif
  endif

#_RT  if ( !($?STAGE4FCST) )    setenv STAGE4FCST  0   # need to resolve redundancies

  if ( $?RUN_OPT_BEGIN ) then
        set run_opt_begin = ( $RUN_OPT_BEGIN ) 
  else 
        set run_opt_begin = ""
  endif

  setenv FORECAST  0
  setenv SVEC      0
  setenv SENS      0
  set grsv =       0 # by default do not copy gradient vector
  set strict =    "" # by default do not be strict about input files
  set log    =     0 # by default do not log warnings or errors 
  set blendg5 =    0 # by default do not blend g5 analysis with rs files   
  set blendrs =    0 # by default do not blend ncep data with rs files
  set blendec =    0 # by default do not blend ncep data with rs files
  set ifcst   =    0 # by default do not initialize forecast, i.e., don't force first 6hr of fcst w/ IAU inc
  set ihh0    =   -1 # by default do not initialize starting hour

  set dryrun = ""

# Define fname1 and fname2 aliases
# --------------------------------
  alias fname1 'echo \!* >! $fname'   # write first line of $fname
  alias fname2 'echo \!* >> $fname'   # append to $fname
 
                                                 # Last line of Initialize_
\end

#.............................................................

#------------------------
 Sub ParseCmdLine_()
#------------------------
  if ( $?ECHO___ ) set echo

  if ( $#argv > 0 ) then
  foreach token ( $argv )
     if ( "$token" == "-dtg" ) then
          shift
          set itime = "$1"
          shift
     endif
     if ( "$token" == "-h" ) then
          goto usage
     endif
     if ( "$token" == "-fcst" ) then
          setenv FORECAST 1
          shift
          set itime = $1
          shift
     endif
     if ( "$token" == "-svec" ) then
          setenv SVEC     1
          setenv FORECAST 1
          shift
          set itime = $1
          shift
     endif
     if ( "$token" == "-sens" ) then
          setenv SENS     1
          setenv FORECAST 1
          shift
          set itime = $1
          shift
     endif
     if ( "$token" == "-grsv" ) then
          set grsv = 1
          shift
     endif
     if ( "$token" == "-n" ) then
          set dryrun = echo
          shift
     endif
     if ( "$token" == "-blendrs" ) then
          set blendrs = 1
          shift
     endif
     if ( "$token" == "-blendec" ) then
          set blendec = 1
          shift
     endif
     if ( "$token" == "-blendg5" ) then
          set blendg5 = 1
          shift
     endif
     if ( "$token" == "-ifcst" ) then
          set ifcst = 1
          shift
     endif
     if ( "$token" == "-ihh0" ) then
          shift
          set ihh0 = $1
          shift
     endif
     if ( "$token" == "-strict" ) then
          set strict = "-strict"  # bomb if not all input files are there
          setenv STRICT 1
          shift
     endif
     if ( "$token" == "-obsclass" ) then
          shift
          set obsclass = $1
          shift
     endif
     if ( "$token" == "-req_obsclass" ) then
          shift
          set req_obsclass = $1
          shift
     endif
     if ( "$token" == "-log" ) then
          set log = 1  # write warning and error messages to log
          shift
     endif
  end
  endif

  if ( $#argv != 2 ) then
       echo $myname": insufficient command line arguments"
       goto usage
  else
       setenv FVHOME  $1
       setenv FVWORK  $2
       setenv EXPID   `basename $FVHOME`
       if ( !($?ANAID) )  setenv ANAID $EXPID 
  endif

# Check for optional directory specifications
# -------------------------------------------
  if ( $?FCHOME ) then
       set fchome = $FCHOME
  else
       set fchome = "${FVHOME}/fcst/"
  endif

  if ( $?FCSTAGE ) then
       set fcstage = $FCSTAGE
  else
       set fcstage = "${FVHOME}/fcst/"
  endif
  if ( $?ECSTAGE ) then
       set ecstage = $ECSTAGE
  else
       set ecstage = "/dev/null"
  endif
  if ( $?NCSTAGE ) then
       set ncstage = $NCSTAGE
  else
       set ncstage = "/dev/null"
  endif

  setenv STAGE4FCST  $fcstage
  setenv STAGE4ECMWF $ecstage
  setenv STAGE4G5NCEP $ncstage

  if ( $?GRSTAGE ) then
       set grstage = $GRSTAGE
  else
       set grstage = "${FVHOME}/asens/"
  endif

  if (! $?RUN_OPT_BLEND ) then
    echo "RUN_OPT_BLEND must be set in script for restart blending"
    exit 97
  endif

  exit 0

usage:

cat <<EOF

NAME
     fvpsas - Script for GMAO Data Assimilation or Forecast runs 
          
SYNOPSIS

     fvpsas [-h] [-fcst itime] [-log]
            [-grsv] fvhome  fvwork

DESCRIPTION

     This script runs the GMAO-GCMs in Data Assimilation or Forecast 
     mode for one job segment. On input:

     fvhome     experiment home directory, e.g., /scratch1/$user/v000_b55
     fvwork     working directory, e.g., \$TMPDIR

     Restarts, namelists and resource files are  expected to be available 
     in \$FVHOME/recycle and \$FVHOME/run.  The run is performed in \$FVWORK,
     and the output files are left there for archival by the calling script.

OPTIONS

     -grsv        copy gradient vector to \$FVHOME/asens 
     -h           prints this page
     -fcst itime  forecast mode; itime specifies the initial condition 
                  time, for example: 19990901_18z
     -strict      returns with non-zero error if acquire fails to
                  resolve all input files
     -obsclass cls1,cls2...  
                  observation data classes, such as conv_tovs,ssmi_wentz_tpw 
     -req_obsclass cls1,cls2
                  observation data classes, such as ncep_prep_bufr, that are REQUIRED for the
                  DAS to run.  These are always run in strict mode.
     -blendrs     blends G5fcst with NCEP analysis to create IC for G5GCM
     -blendec     blends G5fcst with ECMWF analysis to create IC for G5GCM
     -blendg5     blends G5fcst with GEOS-5 analysis to create IC for G5GCM
     -ifcst       force forecast for first 6hrs with IAU increment
     -log         log warning and errors to file
     -dtg itime   specifies time of rsts when running DAS
     -n           dry-run mode: does not run model/analysis

ENVIRONMENT

    PREPQC      if 1, turns NCEP preprocessing QC on.
    SPLITEXE    if 1, runs in GCM/ANA split executable mode.
    SKIPANA     if 1, skips analysis (for debugging purposes).
    VTXRELOC    if 1, enables hurricane vortex relocation
    VTRACK      if 1, enables hurricane track production
    BOOTSTRAP   if 1, allows you to run with missing restarts
    DO_DMGET    if 1, overrides acquire stage operations
    DIAG2ODS    if 1, creates ods files for monitoring
    IGNORE_0    if 1, ignores 0 length obs files in acquire
    CONVSFC     if 1, enables lcv2prs conversion of surface output fields
    CONVUPA     if 1, enables lcv2prs conversion of upper-air output fields

SEE ALSO  

    fvsetup     experiment setup utility
    fvdas.j     Main experiment script created by fvsetup.

EOF

exit 1
                                                 # Last line of ParseCmdLine_
\end

#.............................................................................

#-----------------------
 Sub SanityCheck_()
#-----------------------
  if ( $?ECHO___ ) set echo

# Check whether relevant directories actually exist
# -------------------------------------------------
  if ( ! (-d $FVHOME) ) then
    echo $myname": cannot find FVHOME directory $FVHOME"
    exit 1
  endif
  if ( ! (-d $FVWORK) ) then
    echo $myname": cannot find FVWORK directory $FVWORK"
    exit 1
  endif
  if ( -e $FVHOME/.FVROOT ) then
       setenv FVROOT `cat $FVHOME/.FVROOT`
  else
       echo $myname": cannot find file $FVHOME/.FVROOT"
       exit 1
  endif
  if ( ! (-d $FVROOT) ) then
    echo $myname": cannot find FVROOT directory $FVROOT"
    exit 1
  endif

# Cannot do GAASFDBK unless GAAS_ANA is on 
# ----------------------------------------
  if ( ! $FORECAST ) then
     if ( $GAAS_ANA && ( ! $GAASFDBK ) ) then
       echo $myname": GAAS inconsistency, GAASFDBK=$GAASFDBK, GAAS_ANA=$GAAS_ANA"
       exit 1
     endif
  endif

# For safety, do not run if morgue directory exists
# -------------------------------------------------
  if ( -d $FVHOME/morgue ) then
       echo $myname": detected morgue $FVHOME/morgue; please remove it"
       if ( $log ) then
            Err_Log.pl -N ${EXPID}.job -I $ERROR_ID -X $ERROR_EXP -C 98 \
                       -E 5 $ERROR_LOG_NAME \
                       -D "${EXPID}.job FATAL ERROR: $0 detected morgue $FVHOME/morgue -- please remove it"
       endif
       exit 98
  endif

# A few things do not make sense in forecast mode
# -----------------------------------------------
  if ( $FORECAST ) then
        setenv SKIPANA 1   # no ANALYSIS
  else
        if ( $?MPIRUN_IAU ) then
              set makeiaux = ( $MPIRUN_IAU ) 
        else 
              exit 94
        endif
        if ( $?MPIRUN_IDF ) then
              set idfupdx = ( $MPIRUN_IDF ) 
        else 
              exit 95
        endif
  endif

  if ( $ifcst ) then              # set forecast offset
      if ( !($?FCSTOFFSET) ) then # if ifcst, default is 3hrs due to IAU
         @ foffset_sec =  10800
      else
         @ foffset_sec =  $FCSTOFFSET * 60
      endif
  else                            # else, default is no offset
      if ( !($?FCSTOFFSET) ) setenv FCSTOFFSET 0
      @ foffset_sec =  $FCSTOFFSET
  endif

# Cannot do analysis if no obs class has been specified
# -----------------------------------------------------
  if ( !($?obsclass) && !($?req_obsclass) ) then
        setenv SKIPANA 1   # no ANALYSIS
  endif

# For readability, introduce DOING_ANA
# ------------------------------------
  if ( $SKIPANA ) then
       setenv DOING_ANA 0
  else
       setenv DOING_ANA 1
  endif

  set lnobs = "-lnobs"

                                               # Last line of SanityCheck_
\end

#.........................................................................

# -----------------------------
  Sub CopyResourceFiles_()
# -----------------------------
  if ( $?ECHO___ ) set echo

# Copy resource and restart files to here
# ---------------------------------------
  /bin/cp $FVHOME/run/*.arc           .         # archiving rules
  /bin/cp $FVHOME/run/*.acq           .         # acquiring rules
  /bin/cp $FVHOME/run/*.rc            .         # resource files
  /bin/cp $FVHOME/run/*.namelist      .         # FORTRAN namelists
  /bin/cp $FVHOME/run/*.sed           .         # templates
  /bin/cp $FVHOME/run/*.tbl           .         # fvCCM diagnostic table         
  /bin/cp $FVHOME/run/*.tmpl          .         # any templates
  /bin/cp $FVHOME/run/prepobs*        .         # all parameter files
  /bin/cp $FVHOME/run/gmao_acft_bias.parm .
  if ( -d $FVHOME/run/fsens ) then
      /bin/cp $FVHOME/run/fsens/*.tmpl    .	
      /bin/cp $FVHOME/run/fsens/*.rc      .	
  endif
  if ( -d $FVHOME/run/mom ) then
      /bin/cp $FVHOME/run/mom/*_table     .	
      /bin/cp $FVHOME/run/mom/MOM_*       .	
  endif
  if ( $FORECAST ) then
       foreach file ( `ls ${fchome}/*` )
          if ( $file =~ *.log.* ) continue
          set ext = $file:e            
          if ( "$ext" != "bin" && "$ext" != "$NCSUFFIX" && "$ext" != "tar" ) then
                /bin/cp $file .   # skip restarts
          endif 
       end
       if ( -d $FVHOME/fcst/mom ) then
           /bin/cp $FVHOME/fcst/mom/*_table  .	
           /bin/cp $FVHOME/run/mom/MOM_*     .	
       endif
  endif
  cat fvcore_layout.rc >> input.nml

# Edit and copy GAAS resource files
# ---------------------------------
  foreach file ( `ls $FVHOME/run/gaas/*.rc` )
     set target = $FVWORK/$file:t
     vED -env $file -o $target
     echo "cat $target"
     cat $target
  end

# Get GOCART rc files
# -------------------
  if ( -d "$FVHOME/run/gocart" ) then
       cp $FVHOME/run/gocart/* .
  endif

# Set HISTORY gaas products on or off
# -----------------------------------
  if ( $GAAS_ANA || -e replay_aod.rc ) then
       foreach hist ( `ls HIST*.rc.tmpl` )
          edhist.pl $hist -i -Ipm gaas_bkg
       end
  else
       foreach hist ( `ls HIST*.rc.tmpl` )
          edhist.pl $hist -i -Xdep GAAS
       end
  endif       

# Enable GAAS feedback in the GCM if GAASFDBK is on; Disable if off
# -----------------------------------------------------------------
  if ( $GAASFDBK ) then
       vED -i $FVWORK/GEOS_ChemGridComp.rc -vv ENABLE_GAAS=.TRUE.
       foreach hist ( `ls HIST*.rc.tmpl` )
          edhist.pl $hist -i -Ipm _gas_N
       end
  else
       vED -i $FVWORK/GEOS_ChemGridComp.rc -vv ENABLE_GAAS=.FALSE.
  endif
  echo "cat $FVWORK/GEOS_ChemGridComp.rc"
  cat $FVWORK/GEOS_ChemGridComp.rc

# Edit CARMAchem_Registry.rc file
# -------------------------------
  set rcfile = CARMAchem_Registry.rc
  if (-e $rcfile) then
     set vars = "DU_OPTICS SS_OPTICS BC_OPTICS SM_OPTICS"
     subst_path.pl -i $rcfile fvInput $FVHOME/fvInput $vars
  endif

# Rename AGCM resource file for bootstrap
# ---------------------------------------
  if ( $BOOTSTRAP ) then
      cp -f AGCM.rc.tmpl AGCM.rc.tmpl.HOLD
      cp -f AGCM.BOOTSTRAP.rc.tmpl AGCM.rc.tmpl
  endif 

# Turn off aerosol data sets for local acquire and replay
# -------------------------------------------------------
  if ( $LOCAL_ACQUIRE ) then
      set aerosol_acquire = 0
      setenv USE_MODIS_STAGE 1
  else
      set aerosol_acquire = 1
  endif

# If 4DVAR then link to adjoint nml file
# --------------------------------------
  if (-e fvcorepert_layout_4dvar.rc) then
     ln -s fvcorepert_layout_4dvar.rc inputpert.nml
  endif
  if (-e fvcoretraj_layout.rc) then
     ln -s fvcoretraj_layout.rc input.nml
  endif

                                        # Last line of CopyResourceFiles_ 
\end

#.............................................................................

# ------------------------------------
  Sub CopyGcmRestarts4Forecast_()
# ------------------------------------
  if ( $?ECHO___ ) set echo

  foreach rsf ( d $grs_list )   
     if ( "$rsf" == "d" ) then
        set rsfile = $fcstage/stage/$EXPID.rst.lcv.$itime.bin
     else
        set rsbase = $fcstage/stage/$EXPID.${rsf}_rst.$itime
        set rsfile = $rsbase.nc4
        if (! -e $rsfile) then
            set rsfile = $rsbase.bin
            if (! -e $rsfile) then
                if ("$grs_boot" =~ *$rsf*) continue
            endif
        endif
     endif
     ln -s $rsfile ./${rsf}_rst 
  end

  set itime_hhmm = $itime:s/z/00z/
  if ( -e $fcstage/stage/$EXPID.traj_lcv_rst.$itime_hhmm.$NCSUFFIX ) then
      /bin/ln -s $fcstage/stage/$EXPID.traj_lcv_rst.$itime_hhmm.$NCSUFFIX ./$EXPID.traj.lcv.$itime_hhmm.$NCSUFFIX
  endif
# if ( -e $fcstage/stage/$EXPID.ptrj_prs_rst.$itime_hhmm.$NCSUFFIX ) then
#     /bin/ln -s $fcstage/stage/$EXPID.ptrj_prs_rst.$itime_hhmm.$NCSUFFIX ./$EXPID.ptrj.prs.$itime_hhmm.$NCSUFFIX
# endif

  set dtg = ( `rst_date d_rst` )
  set prog_dtg1 = `tick $dtg[1]`
  set prog_dtg2 = `tick $prog_dtg1`

  set GcmBegDate = $dtg[1] # for consistency
  set GcmBegTime = $dtg[2] # for consistency

                                  # Last line of CopyGcmRestarts4Forecast_
\end

#.............................................................................

# --------------------------------
  Sub CopyGcmRestarts4DAS_()
# --------------------------------
  if ( $?ECHO___ ) set echo

  foreach rs ( d $grs_list )
     if ( "$rs" == "d" ) then
        set rsfile = $FVHOME/recycle/$EXPID.rst.lcv.$itime.bin
        /bin/cp $rsfile ./d_rst
        set mydate = (`rst_date ./d_rst`)
     else
        set rsbase = $FVHOME/recycle/$EXPID.${rs}_rst.$itime
        set rsfile = $rsbase.nc4
        if (! -e $rsfile) then
            set rsfile = $rsbase.bin
            if (! -e $rsfile) then
                if ("$grs_boot" =~ *$rs*) continue
            endif
        endif
        /bin/cp $rsfile ./${rs}_rst & 
     endif
  end


  set GcmBegDate = $mydate[1]
                              # Last line of CopyGcmRestarts4DAS_
\end

#.............................................................................

# ------------------------------------
  Sub CopyMOMRestarts_( FcstCase_ )
# ------------------------------------
  if ( $?ECHO___ ) set echo

  if ( ! -d $FVHOME/run/mom ) exit 0

# Bring restarts from recycle into work dir
# -----------------------------------------
  set momrst_failed = 0
  if ( $FcstCase_ ) then 
       echo "Not ready to hand Coupled forecasts, aborting ..."
       Call AbnormalExit_( 1 )
  else  # DASCase
     foreach this ( mom_rst mom1_rst mom2_rst mom3_rst )
        set momrs = $FVHOME/recycle/$EXPID.$this.$itime.nc4
        if ( -e $momrs ) then
           /bin/cp $momrs $this
        else
           @ momrst_failed = $momrst_failed + 1
        endif
     end
  endif
  if ( $momrst_failed ) then
       echo "Trouble setting up MOM restarts, aborting ..."
       Call AbnormalExit_( 2 )
  endif

#  Find out where MOM expects restarts to be
#  -----------------------------------------
  if ( ! -e fvcore_layout.rc ) then
       echo "Trouble finding layout RC, aborting ..."
       Call AbnormalExit_( 1 )
  endif
  set mominpdir = `nmlread.py fvcore_layout.rc MOM_input_nml restart_input_dir`
  if ( ! -d $mominpdir ) mkdir $mominpdir

  set momoutdir = `nmlread.py fvcore_layout.rc MOM_input_nml restart_output_dir`
  if ( ! -d $momoutdir ) mkdir $momoutdir

#  Move MOM to location MOM expects them
#  -------------------------------------
  @ momrst_failed = 0
  if ( -e mom_rst  ) then
     /bin/mv mom_rst $mominpdir/MOM.res.nc
  else
     @ momrst_failed = $momrst_failed + 1
  endif
  foreach momrst ( 1 2 3 )
     if ( -e mom${momrst}_rst ) then
        /bin/mv mom${momrst}_rst $mominpdir/MOM.res_${momrst}.nc
     else
        @ momrst_failed = $momrst_failed + 1
     endif
  end
  if ( $momrst_failed ) then
       echo "Trouble setting up MOM restarts, aborting ..."
       Call AbnormalExit_( 2 )
  endif

                              # Last line of CopyMOMRestarts_
\end

#.............................................................................

# -----------------------------
  Sub VerifyGcmRestarts_()
# -----------------------------
  if ( $?ECHO___ ) set echo

# Create a file with date and time for GEOS-5 GCM
# -----------------------------------------------
  /bin/rm -rf      cap_restart
  rst_date d_rst > cap_restart

# Make sure restarts are present
# ------------------------------
  foreach rs ( d $grs_list )
     set rsfile = ${rs}_rst
     if (! -e $rsfile ) then
        echo $myname": missing $rs"
        if ("$grs_boot" =~ *$rs*) then
            if ($rs != "saltwater_internal_rst") continue
        endif
        if ($rs !~ agcm_* && $rs !~ aiau_* ) exit 1         # IAU file not a restart
     endif
  end

                                  # Last line of CopyGcmRestarts4Forecast_
\end

#.............................................................................

# ---------------------------------------
  Sub UpdateHistoryResource4Blend_Fcst_()
# ---------------------------------------
  if ( $?ECHO___ ) set echo

  if ($ihh0 >= 0) then
     set rundt = `grep "^HEARTBEAT_DT:" CAP_${ihh0}.rc.tmpl | cut -d: -f2`
  else
     set rundt = `grep "^HEARTBEAT_DT:" CAP.rc.tmpl | cut -d: -f2`
  endif
  set vtxref= ( `tick $dtg  $rundt` )
  set asmdate = ( `tick $dtg 21600` )

  rm -f sed_file
  echo "s/>>>REFDATE<<</${vtxref[1]}/1"     > sed_file
  echo "s/>>>REFTIME<<</${vtxref[2]}/1"    >> sed_file
  echo "s/>>>PROGREF<<</${dtg[2]}/g"       >> sed_file
  echo "s/>>>IOEDATE<<</${asmdate[1]}/g"   >> sed_file
  echo "s/>>>IOETIME<<</${asmdate[2]}/g"   >> sed_file
  echo "s/>>>NCSUFFIX<<</${NCSUFFIX}/1"    >> sed_file
  /bin/rm -f ./HISTORY.rc
  sed -f sed_file  ./HISTORY.rc.tmpl  > ./HISTORY.rc
  cat ./HISTORY.rc

  if ( -e $fcstage/stage/$EXPID.vtx_prs_rst.$itime.$NCSUFFIX ) then
       set vtxfile = `echo $EXPID.vtx_prs_rst.$itime.$NCSUFFIX | sed -e 's/vtx_prs_rst/vtx.prs/'`
       ln -s  $fcstage/stage/$EXPID.vtx_prs_rst.$itime.bin   ./$vtxfile
  endif

  if(-e ExtData.rc )    /bin/rm -f   ExtData.rc
  cd $FVHOME/run/gocart
  set  extdata_files = `/bin/ls -1 *_ExtData.rc`
  cat $extdata_files > $FVWORK/ExtData.rc 
  set hh = `echo $gcm_nhms0 | cut -c1-2`
  if ( ${gcm_nymd0}${hh} >= 2021103021 ) then
     foreach line (`grep -ni qfed $FVWORK/ExtData.rc | gawk '{print $1}' FS=":"`)
       sed -i "${line}s/.006./.061./" $FVWORK/ExtData.rc
     end
  endif
  cd -
# /bin/cp ExtData.rc $EXPID.ExtData.$itime.rc

                              # Last line of UpdateHistoryResource4Blend_Fcst_()
\end

#.............................................................................

# ---------------------------------------
  Sub SetupObserver_( Viter_, Final_ )
# ---------------------------------------
  if ( $?ECHO___ ) set echo

     @  jiter = $Viter_ + 1
     if( -e OBS_GridComp_${jiter}.rc.tmpl ) then
        set this_obsvrA_ftmpl = OBS_GridComp_${jiter}.rc.tmpl
        set this_obsvrB_ftmpl = obs_${jiter}.rc.tmpl
     else
        set this_obsvrA_ftmpl = OBS_GridComp.rc.tmpl
        set this_obsvrB_ftmpl = obs.rc.tmpl
     endif
     set anadt = `grep "^RUN_DT:" $this_obsvrA_ftmpl | cut -d: -f2`
     @ adtbck = $aoffset_sec
     @ adtfwd = $varwindow_sec 
     set beg_ana = ( $gcm_nymd0 $gcm_nhms0 )
     set end_ana = ( `tick $beg_ana[1] $beg_ana[2] $adtfwd` )

     /bin/rm -f sed_file
     echo "s/>>>EXPID<<</${EXPID}/1"         > sed_file
     echo "s/>>>IOBBKGD<<</${beg_ana[1]}/1" >> sed_file
     echo "s/>>>IOBBKGT<<</${beg_ana[2]}/1" >> sed_file
     echo "s/>>>IOEBKGD<<</${end_ana[1]}/1" >> sed_file
     echo "s/>>>IOEBKGT<<</${end_ana[2]}/1" >> sed_file
     echo "s/>>>RECANA<<</NO/1"             >> sed_file
     echo "s/>>>NCSUFFIX<<</${NCSUFFIX}/1"  >> sed_file
     if ( $DO4DVAR ) then
          set wrt_ana = ( `echo $beg_ana` )   # 4dvar observer has initial integration time as reference time
          echo "s/>>>ANADATE<<</${wrt_ana[1]}/1" >> sed_file
          echo "s/>>>ANATIME<<</${wrt_ana[2]}/1" >> sed_file
     else                                     # 3dvar observer has synoptic-time as reference time 
          echo "s/>>>ANADATE<<</${nymdb}/1"      >> sed_file
          echo "s/>>>ANATIME<<</${nhmsb}/1"      >> sed_file
     endif
     /bin/rm -f ./GSI_GridComp.rc
     sed -f sed_file  ./$this_obsvrA_ftmpl  > ./GSI_GridComp.rc
 
#    Append observation table to the grid-comp
#    -----------------------------------------
     append_gsigcrc.pl $FVWORK/obsys.rc GSI_GridComp.rc
     if ( $status ) then
          echo "SetupObserver_: trouble appending obs table to GSI_GridComp.rc "
          Call AbnormalExit_( 3 )
     endif

#    Extract analysis resolution
#    ---------------------------
     set gsinlat = `echorc.x -rc GSI_GridComp.rc "GSI JM"` 
     set gsinlon = `echorc.x -rc GSI_GridComp.rc "GSI IM"` 
     set gsinlev = `echorc.x -rc GSI_GridComp.rc "GSI LM"` 

#    Prepare main GSI resource file
#    -------------------------------
     /bin/rm -f sed_file
     set miter = $NVAROUTER   # total number of iterations
     echo "s/>>>MITER<<</$miter/g"             > sed_file     # maximum number of iteration
     echo "s/>>>JITERSTART<<</$jiter/g"       >> sed_file     # set current iteration
     if ( $Viter_ == 0 || $Final_ ) then
          echo "s/>>>GSIWRTDIAG<<</.true./g"  >> sed_file     # turn on diagnostics in GSI (omf/oma)
     else
          echo "s/>>>GSIWRTDIAG<<</.false./g" >> sed_file     # turn off diagnostics during intermediate iterations
     endif
     # control aircraft bias correction

     switch( $ACFTBIAS )
     case 0:
          echo "s/>>>AIRCFT_BIAS<<<//g"   >> sed_file
	  echo 'Not using aircraft bias correction in GSI'
	  breaksw
     case 1:
          echo "s/>>>AIRCFT_BIAS<<</aircraft_t_bc_ext=.true.,/g"  >> sed_file
	  echo 'Setting aircraft_t_bc_ext to true, using external bias correction'
	  breaksw
     case 2:
          echo "s/>>>AIRCFT_BIAS<<</aircraft_t_bc=.true.,cleanup_tail=.true.,/g"  >> sed_file
	  echo 'Setting aircraft_t_bc to true, using VV.VV^2 bias correction'
	  breaksw
     case 3:
          echo "s/>>>AIRCFT_BIAS<<</aircraft_t_bc_pof=.true.,cleanup_tail=.true.,/g"  >> sed_file
	  echo 'Setting aircraft_t_bc_pof to true, using POF bias correction'
	  breaksw
     default:
          echo "s/>>>AIRCFT_BIAS<<<//g"   >> sed_file
	  echo 'Using default setting, not using aircraft bias correction in GSI'
	  breaksw
     endsw

     # control satwnd source based on date ...
     if ( $beg_ana[1] < 20100701 ) then
        echo "s/>>>USE_PREPB_SATWND<<</.true./g"  >> sed_file
     else
        echo "s/>>>USE_PREPB_SATWND<<</.false./g" >> sed_file
     endif
     /bin/rm -f ./gsi.rc
     sed -f sed_file  ./$this_obsvrB_ftmpl  > ./gsi.rc
     cat gsi.rc

     # create links GSI needs to observations files
     # --------------------------------------------
     if ( $Viter_ == 0 ) then
        ln -sf $FVWORK Obsloc
        @ tauanl = $VAROFFSET * 60
        set wrt_inc = ( `tick $wrt_ana[1] $wrt_ana[2] $tauanl` )
        echo "s/>>>ANADATE<<</${wrt_inc[1]}/1" >> sed_file
        echo "s/>>>ANATIME<<</${wrt_inc[2]}/1" >> sed_file
        match_obcls_obsys.pl $wrt_inc[1] $wrt_inc[2] GSI_GridComp.rc gsi.rc
     endif

#    Finally setup observer inputs
#    -----------------------------
     $dryrun analyzer $nymdb $nhmsb -expid $EXPID -t $SPECRES -levs $gsinlev -x $gsinlon -y $gsinlat -observer $lnobs -log obs.log
     if ( ${status} ) then
         Call AbnormalExit_( 3 )
     endif

     if ( $ANGLEBC && $DIAGTAR ) then
       ls -l radstat
       $dryrun make_diagtarfile.csh $EXPID $nymdb $nhmsb radstat
       ls -l radstat
     endif
                            # Last line of SetupObserver
\end

#.............................................................................

# ---------------------------------------
  Sub RunSplitObserver_( Viter_, Final_ )
# ---------------------------------------
  if ( $?ECHO___ ) set echo

# This function runs the observer in split mode, that is, outside GCM
# It requires call to SetupObserver to have taken place before hand

   @ viterp1 =  $Viter_ + 1

   if ( ($?MPIRUN_OBSVR ) ) then
      $MPIRUN_OBSVR |& tee -a sobs.log
      if ( $Final_ ) then # remove all bkg files except at edges of time window
           rndasfiles -clean $EXPID bkg.eta $beg_ana[1] $beg_ana[2] \
                                            $end_ana[1] $end_ana[2] $ASYNBKG $viterp1
           rndasfiles -clean $EXPID bkg.sfc $beg_ana[1] $beg_ana[2] \
                                            $end_ana[1] $end_ana[2] $ASYNBKG $viterp1
      endif
      set hh_ana = `echo $beg_ana[2]  | cut -c1-2`
      touch $EXPID.sobs_stats.log.${beg_ana[1]}_${hh_ana}z.txt
      cat `ls fort.2*`>> $EXPID.sobs_stats.log.${beg_ana[1]}_${hh_ana}z.txt
      if ( -z $EXPID.sobs_stats.log.${beg_ana[1]}_${hh_ana}z.txt ) then
         echo " Observer stats log file is empty, aborting "
         exit 3
      endif
   else
      echo " Env Var MPIRUN_ANA undefined, aborting "
      exit 3
   endif

                            # Last line of RunSplitObserver
\end

#.............................................................................
# ---------------------------------------
  Sub WrapupObserver_( Viter_, Final_ )
# ---------------------------------------
  if ( $?ECHO___ ) set echo

  @ myiter = $Viter_ + 1
  if ( ($?NCPUS) ) then
    @ nproc = $NCPUS / 4
    if ($nproc < 1 ) set nproc = 1
  else
    set nproc = 1
  endif
  zeit_ci.x gsidiags
  if ( $Final_ ) then
       gsidiags -jiter $myiter -tag anl $nymdb $nhmsb $EXPID set
#_RT   gsidiags -ncpus $nproc -jiter $myiter -tag anl $nymdb $nhmsb $EXPID set
#      Run satellite bias correction
       sac.pl $FVWORK $EXPID $nymdb $nhmsb
  else if ( $Viter_ == 0 ) then
       gsidiags -jiter $myiter -tag ges $nymdb $nhmsb $EXPID set
#_RT   gsidiags -ncpus $nproc -jiter $myiter -tag ges $nymdb $nhmsb $EXPID set
  else # for now, ignore intermediate diag files
       echo " ignoring intermediate diag files from GSI "
#      gsidiags -ncpus $nproc -jiter $myiter          $nymdb $nhmsb $EXPID set
  endif
  zeit_co.x gsidiags

                            # Last line of SetupObserver
\end
#.............................................................................
# ---------------------------------------
  Sub UpdateGsiGridCompResource_( Viter_, Final_ )
# ---------------------------------------
  if ( $?ECHO___ ) set echo

     if ( $DO4DVAR && $Final_ ) exit 0

     @ iterp1 = $Viter_ + 1
     if ( $DO4DVAR ) then
        set anadt = `grep "^RUN_DT:" GSI_GridComp_${iterp1}.rc.tmpl | cut -d: -f2`
     else
        set anadt = `grep "^RUN_DT:" GSI_GridComp.rc.tmpl | cut -d: -f2`
     endif
     @ adtbck = $aoffset_sec
     @ adtfwd = $varwindow_sec
     set beg_ana = ( $gcm_nymd0 $gcm_nhms0 )
     set end_ana = ( `tick $beg_ana[1] $beg_ana[2] $adtfwd` )

#    Prepare GSI_GridComp resource file
#    ----------------------------------
     /bin/rm -f sed_file
     /bin/rm -f ./GSI_GridComp.rc
     echo "s/>>>EXPID<<</${EXPID}/1"         > sed_file
     echo "s/>>>IOBBKGD<<</${beg_ana[1]}/1" >> sed_file
     echo "s/>>>IOBBKGT<<</${beg_ana[2]}/1" >> sed_file
     echo "s/>>>IOEBKGD<<</${end_ana[1]}/1" >> sed_file
     echo "s/>>>IOEBKGT<<</${end_ana[2]}/1" >> sed_file
     echo "s/>>>NCSUFFIX<<</${NCSUFFIX}/1"  >> sed_file
     if ( $DO4DVAR ) then
          if ( $Final_ ) then
             set wrt_ana = ( `echo $beg_ana` )
             echo "s/>>>RECANA<<</NO/1" >> sed_file
          else
             set wrt_ana = ( `echo $beg_ana` )
             echo "s/>>>RECANA<<</YES/1" >> sed_file
          endif
          if ( $WCONSTRAINT ) then  # WCONSTRAINT for now only controls FGAT
                                    # in this case, ana writes inc in middle
                                    # of time period
            @ tauanl = $VAROFFSET * 60
            set wrt_inc = ( `tick $wrt_ana[1] $wrt_ana[2] $tauanl` )
            echo "s/>>>ANADATE<<</${wrt_inc[1]}/1" >> sed_file
            echo "s/>>>ANATIME<<</${wrt_inc[2]}/1" >> sed_file
          else
            echo "s/>>>ANADATE<<</${wrt_ana[1]}/1" >> sed_file
            echo "s/>>>ANATIME<<</${wrt_ana[2]}/1" >> sed_file
          endif
          sed -f sed_file  ./GSI_GridComp_${iterp1}.rc.tmpl  > ./GSI_GridComp.rc
     else
          echo "s/>>>ANADATE<<</${nymdb}/1"      >> sed_file
          echo "s/>>>ANATIME<<</${nhmsb}/1"      >> sed_file
          echo "s/>>>RECANA<<</YES/1"            >> sed_file
          sed -f sed_file  ./GSI_GridComp.rc.tmpl  > ./GSI_GridComp.rc
     endif

#    Append observation table to the grid-comp
#    -----------------------------------------
     append_gsigcrc.pl $FVWORK/obsys.rc GSI_GridComp.rc
     if ( $status ) then
          echo "UpdateGsiGridCompResource_: trouble appending obs table to GSI_GridComp.rc "
          Call AbnormalExit_( 3 )
     endif

     cat GSI_GridComp.rc

#    Extract analysis resolution
#    ---------------------------
     set gsinlat = `echorc.x "GSI JM" -rc GSI_GridComp.rc`
     set gsinlon = `echorc.x "GSI IM" -rc GSI_GridComp.rc`
     set gsinlev = `echorc.x "GSI LM" -rc GSI_GridComp.rc`

#    Prepare main GSI resource file
#    -------------------------------
     /bin/rm -f sed_file
     set miter = $NVAROUTER  # total number of iterations
     echo "s/>>>MITER<<</$miter/g"             > sed_file # maximum number of iteration
     if ( $Viter_ == 0 || $Final_ ) then
          echo "s/>>>GSIWRTDIAG<<</.true./g"  >> sed_file     # turn on diagnostics in GSI (omf/oma)
     else
          echo "s/>>>GSIWRTDIAG<<</.false./g" >> sed_file     # turn off diagnostics during intermediate iterations
     endif
     if ( $Viter_ == 0 ) then
          echo "s/>>>IGUESS<<</0/g"           >> sed_file     # in the 1st iteration, only write initial guess file
     else
          echo "s/>>>IGUESS<<</1/g"           >> sed_file     # all other iterations, read and write initial guess file
     endif
     @ jiter = $Viter_ + 1
     echo "s/>>>JITERSTART<<</$jiter/g"       >> sed_file     # set current iteration
     # control aircraft bias correction

     switch( $ACFTBIAS )
     case 0:
          echo "s/>>>AIRCFT_BIAS<<<//g"   >> sed_file
	  echo 'Not using aircraft bias correction in GSI'
	  breaksw
     case 1:
          echo "s/>>>AIRCFT_BIAS<<</aircraft_t_bc_ext=.true.,/g"  >> sed_file
	  echo 'Setting aircraft_t_bc_ext to true, using external bias correction'
	  breaksw
     case 2:
          echo "s/>>>AIRCFT_BIAS<<</aircraft_t_bc=.true.,cleanup_tail=.true./g"  >> sed_file
	  echo 'Setting aircraft_t_bc to true, using VV.VV^2 bias correction'
	  breaksw
     case 3:
          echo "s/>>>AIRCFT_BIAS<<</aircraft_t_bc_pof=.true.,cleanup_tail=.true./g"  >> sed_file
	  echo 'Setting aircraft_t_bc_pof to true, using POF bias correction'
	  breaksw
     default:
          echo "s/>>>AIRCFT_BIAS<<<//g"   >> sed_file
	  echo 'Using default setting, not using aircraft bias correction in GSI'
	  breaksw
     endsw

      # control satwnd source based on date ...
     if ( $beg_ana[1] < 20100701 ) then
        echo "s/>>>USE_PREPB_SATWND<<</.true./g"  >> sed_file
     else
        echo "s/>>>USE_PREPB_SATWND<<</.false./g" >> sed_file
     endif
     /bin/rm -f ./gsi.rc
     if ( $DO4DVAR ) then
        if( -e gsi_fdda_${iterp1}.rc.tmpl ) then
            sed -f sed_file  ./gsi_fdda_${iterp1}.rc.tmpl  > ./gsi.rc
        endif
        if( -e gsi_fgat_${iterp1}.rc.tmpl ) then
            sed -f sed_file  ./gsi_fgat_${iterp1}.rc.tmpl  > ./gsi.rc
         endif
     else
        sed -f sed_file  ./gsi.rc.tmpl       > ./gsi.rc
     endif
     cat gsi.rc

                            # Last line of UpdateGsiGridCompResource
\end
                                                                                                                                              

#.............................................................................

# ------------------------------------------
  Sub UpdateHistoryResource4Forecast_()
# ------------------------------------------
  if ( $?ECHO___ ) set echo

     set TrjBegDate = $TrjBegEpoch[1]
     set TrjBegTime = $TrjBegEpoch[2]
     set TrjEndDate = $TrjEndEpoch[1]
     set TrjEndTime = $TrjEndEpoch[2]

     set hh_beg = `echo $itime | cut -c10-11`

#    Create GCM-output control file from its template
#    ------------------------------------------------
     /bin/rm -f sed_file
     if ( $ifcst ) then
        @ rundt  = $foffset_sec # offset time from synoptic hour
     else
        if ($ihh0 >= 0) then
           set rundt = `grep "^HEARTBEAT_DT:" CAP_${ihh0}.rc.tmpl | cut -d: -f2`
        else
           set rundt = `grep "^HEARTBEAT_DT:" CAP.rc.tmpl | cut -d: -f2`
        endif
     endif
     set initref = ( `tick $dtg  $rundt` )

     @ hh =  $rundt / 3600
     @ mn = ($rundt - (3600 * $hh)) / 60
     set hh = `echo $hh |awk '{printf "%02d", $1}'`
     set mn = `echo $mn |awk '{printf "%02d", $1}'`
     set trajfrqhms = ${hh}${mn}00

     echo "s/>>>REFDATE<<</${initref[1]}/g"    > sed_file
     echo "s/>>>REFTIME<<</${initref[2]}/g"   >> sed_file
     echo "s/>>>IOBTRJD<<</$TrjBegDate/1"     >> sed_file
     echo "s/>>>IOBTRJT<<</$TrjBegTime/1"     >> sed_file
     echo "s/>>>IOETRJD<<</$TrjEndDate/1"     >> sed_file
     echo "s/>>>IOETRJT<<</$TrjEndTime/1"     >> sed_file   
     echo "s/>>>TRAJFRQ<<</$trajfrqhms/1"     >> sed_file   
     echo "s/>>>NCSUFFIX<<</${NCSUFFIX}/1"    >> sed_file
     /bin/rm -f HISTORY.rc
     if ( -e HISTORY_${hh_beg}.rc.tmpl ) then
       sed -f sed_file  ./HISTORY_${hh_beg}.rc.tmpl  > ./HISTORY.rc
     else
       sed -f sed_file  ./HISTORY.rc.tmpl  > ./HISTORY.rc
     endif
     cat HISTORY.rc

     if ( -e $fcstage/stage/$EXPID.vtx_prs_rst.$itime.$NCSUFFIX ) then
        set vtxfile = `echo $EXPID.vtx_prs_rst.$itime.$NCSUFFIX | sed -e 's/vtx_prs_rst/vtx.prs/'`
        ln -s  $fcstage/stage/$EXPID.vtx_prs_rst.$itime.bin   ./$vtxfile
     endif

                         # Last line of UpdateHistoryResource4Forecast_() 
\end

#.............................................................................
# ------------------------------------------
  Sub SetShortRangeFcst_()
# ------------------------------------------
  if ( $?ECHO___ ) set echo

  setenv SHORTFCST 1

                              # Last line of UpdateHistoryResource4Forecast_() 
\end
#.............................................................................
# ------------------------------------------
  Sub unSetShortRangeFcst_()
# ------------------------------------------
  if ( $?ECHO___ ) set echo

  setenv SHORTFCST 0

\end
#.............................................................................

# ------------------------------------------
  Sub UpdateHistoryResource4SplitExec_( Viter_, Final_ )
# ------------------------------------------
  if ( $?ECHO___ ) set echo

  if ( $SHORTFCST ) then

#    Don't need any model output during the short-time forecast
#    ----------------------------------------------------------
     /bin/rm -f sed_file
     echo "EXPID:  $EXPID "   > sed_file
     echo "EXPDSC: $EXPID "  >> sed_file
     /bin/mv sed_file ./HISTORY.rc

  else

#    In case forecast sensitivity runs will take place, need to save part of trajectory
#    ----------------------------------------------------------------------------------
     if ( ! `grep -c "@" saverst.rc` ) then
          set saverst   = `cat saverst.rc`
          set tot2store = `echo $#saverst`
          set id0       = 0
          while ( $id0 < $tot2store )
             @ id0++
             set saveme    = "$saverst[$id0]"
             if ( "$wrt_fcs_nhms" == "${saveme}0000" ) then
                 set fcs_nymdi = $nymdb
                 set fcs_nhmsi = ${saveme}0000
             endif
          end  # < id0 >
       #--endif  # < -e saverst.rc >
     else 
       set fcs_nymdi = 22000101  # dummy date
       set fcs_nhmsi = 000000    # dummy time
     endif  # < -e saverst.rc >

     if ( -e $fcstage/initadj.rc ) then
           set fcs_nymdi = $nymdb
           set fcs_nhmsi = $nhmsb
     endif # < -e initadj.rc >

     if ( $ihh0 >= 0 ) then
        set rundt = `grep "^HEARTBEAT_DT:" CAP_${ihh0}.rc.tmpl | cut -d: -f2`
     else
        set rundt = `grep "^HEARTBEAT_DT:" CAP.rc.tmpl | cut -d: -f2`
     endif
     @ hh =  $rundt / 3600
     @ mn = ($rundt - (3600 * $hh)) / 60
     set hh = `echo $hh |awk '{printf "%02d", $1}'`
     set mn = `echo $mn |awk '{printf "%02d", $1}'`
     set trajfrqhms = ${hh}${mn}00

     set qcref = `tick $wrt_rst_nymd $wrt_rst_nhms $varwindow_sec`  # tick time to synoptic hour
     set ioebkgd = ${qcref[1]}  # date to stop writing background files
     set ioebkgt = ${qcref[2]}  # time to stop writing background files

     /bin/rm -f sed_file
     echo "s/>>>IOEDATE<<</${gcm_nymdb}/1" > sed_file
     echo "s/>>>IOETIME<<</${gcm_nhmsb}/1" >> sed_file
     if ( $DOIAU ) then
          set TrjBegDate = $TrjBegEpoch[1]
          set TrjBegTime = $TrjBegEpoch[2]
          set TrjEndDate = $TrjEndEpoch[1]
          set TrjEndTime = $TrjEndEpoch[2]

          set qcref = `tick $wrt_rst_nymd $wrt_rst_nhms 10800`  # tick time to synoptic hour
          set qcref_nymd = ${qcref[1]}
          set qcref_nhms = ${qcref[2]}
          echo "s/>>>IOBBKGD<<</${wrt_rst_nymd}/1" >> sed_file  # for IAU, only write bkg's at later half of integration
          echo "s/>>>IOBBKGT<<</${wrt_rst_nhms}/1" >> sed_file
          echo "s/>>>IOBQCD<<</${qcref_nymd}/1"    >> sed_file   
          echo "s/>>>IOBQCT<<</${qcref_nhms}/1"    >> sed_file
          echo "s/>>>IOEQCD<<</${qcref_nymd}/1"    >> sed_file   
          echo "s/>>>IOEQCT<<</${qcref_nhms}/1"    >> sed_file
          echo "s/>>>IOBTRJD<<</$TrjBegDate/1"     >> sed_file
          echo "s/>>>IOBTRJT<<</$TrjBegTime/1"     >> sed_file
          echo "s/>>>IOETRJD<<</$TrjEndDate/1"     >> sed_file
          echo "s/>>>IOETRJT<<</$TrjEndTime/1"     >> sed_file   
          echo "s/>>>TRAJFRQ<<</$trajfrqhms/1"     >> sed_file   
     else
          echo "s/>>>IOBBKGD<<</17760704/1"   >> sed_file       # write bkg's from begining of time
          echo "s/>>>IOBBKGT<<</000000/1"     >> sed_file
     endif
     echo "s/>>>IOEBKGD<<</${ioebkgd}/1"      >> sed_file
     echo "s/>>>IOEBKGT<<</${ioebkgt}/1"      >> sed_file   
     echo "s/>>>FCSDATE<<</${fcs_nymdi}/1"    >> sed_file
     echo "s/>>>FCSTIME<<</${fcs_nhmsi}/1"    >> sed_file
     echo "s/>>>NCSUFFIX<<</${NCSUFFIX}/1"    >> sed_file

#    set date/times for gaas_bkg.sfc outputs
#    ---------------------------------------
     set rstdate = ( `rst_date ./d_rst` )
     if ( $DO4DVAR ) then
        set gaasDateTimeBeg = ( `tick $rstdate 0 030000` )
        set gaasDateTimeEnd = ( `tick $rstdate 0 060000` )
     else
        set gaasDateTimeBeg = ( `tick $rstdate 0 090000` )
        set gaasDateTimeEnd = ( `tick $rstdate 0 120000` )
     endif

     set gaasDateBeg = $gaasDateTimeBeg[1]
     set gaasTimeBeg = $gaasDateTimeBeg[2]

     set gaasDateEnd = $gaasDateTimeEnd[1]
     set gaasTimeEnd = $gaasDateTimeEnd[2]

     echo "s/>>>GAASDATEBEG<<</$gaasDateBeg/" >> sed_file
     echo "s/>>>GAASTIMEBEG<<</$gaasTimeBeg/" >> sed_file
     echo "s/>>>GAASDATEEND<<</$gaasDateEnd/" >> sed_file
     echo "s/>>>GAASTIMEEND<<</$gaasTimeEnd/" >> sed_file

#    set date/times for gaas inst outputs
#    ------------------------------------
     set IgaasDateTimeBeg = ( `tick $rstdate 0 030000` )
     set IgaasDateTimeEnd = ( `tick $rstdate 0 060000` )

     set IgaasDateBeg = $IgaasDateTimeBeg[1]
     set IgaasTimeBeg = $IgaasDateTimeBeg[2]

     set IgaasDateEnd = $IgaasDateTimeEnd[1]
     set IgaasTimeEnd = $IgaasDateTimeEnd[2]

     echo "s/>>>IGAASDATEBEG<<</$IgaasDateBeg/" >> sed_file
     echo "s/>>>IGAASTIMEBEG<<</$IgaasTimeBeg/" >> sed_file
     echo "s/>>>IGAASDATEEND<<</$IgaasDateEnd/" >> sed_file
     echo "s/>>>IGAASTIMEEND<<</$IgaasTimeEnd/" >> sed_file

     /bin/rm -f HISTORY.rc
     if ( $DO4DVAR ) then
        if ( $Final_ ) then

#           Which HISTORY to use?
#           ---------------------
            set hh = `echo $gcm_nhms0 | cut -c1-2`
            set myhist = HISTFDDAL.rc.tmpl
            if ( -e HISTFDDAL_${hh}.rc.tmpl ) set myhist = HISTFDDAL_${hh}.rc.tmpl
            sed -f sed_file  $myhist > ./HISTORY.rc    # full  diagnostics at final iteration

        else
            if ( -e HISTFDDA_${iterp1}.rc.tmpl ) then
               set this_hist = HISTFDDA_${iterp1}.rc.tmpl
            else
               if ( -e HISTFDDA.rc.tmpl ) then
                  set this_hist = HISTFDDA_${iterp1}.rc.tmpl
               else
                  echo "Failed, cannot find proper HISTORY file - Aborting ..."
                  exit 99
               endif
            endif
            @ iterp1 = $Viter_ + 1
            sed -f sed_file  ./$this_hist  > ./HISTORY.rc    # short diagnostics within outer loop
        endif
     else

#      Which HISTORY to use?
#      ---------------------
       set hh = `echo $gcm_nhms0 | cut -c1-2`
       set myhist = HISTORY.rc.tmpl
       if ( -e HISTORY_${hh}.rc.tmpl ) set myhist = HISTORY_${hh}.rc.tmpl
        sed -f sed_file  $myhist  > ./HISTORY.rc    # full  diagnostics all other cases

     endif
     cat ./HISTORY.rc

  endif # < SHORTFCST >

                        # Last line of UpdateHistoryResource4SplitExec_() 

\end

#.............................................................................

# --------------------------------------
  Sub BlendGcmNcepRestarts4Fcst_()
# -------------------------------------
  if ( $?ECHO___ ) set echo

  if (! $?RUN_OPT_BLEND ) then
    echo "RUN_OPT_BLEND must be set in script for restart blending"
    exit 97
  endif

  /bin/ls -l
  set three_hrs_sec = 10800 # three-hours in secs
  set dtg = ( `rst_date d_rst` )
  set dtg = ( `tick $dtg $three_hrs_sec ` )
  set nymd = ${dtg[1]}
  set nhms = ${dtg[2]}
  set hour = `echo ${dtg[2]} | cut -c1-2`
  set ncepeta_ana_file = `echorc.x -template $EXPID $dtg[1] $dtg[2] -rc blendrs.rc ncepeta_ana_file`
 
  ncep2geos.pl -prs $dtg[1] $dtg[2]
     if ( -e   $ncepeta_ana_file ) then
        ln -sf $ncepeta_ana_file ana4replay.eta.{$dtg[1]}_${hour}z.$NCSUFFIX
     else
       echo "Failed in ncep2geos.pl failed - Aborting ..."
       exit 97
     endif

                              # Last line of BlendGcmNcepRestarts4Fcst_()
\end

#.............................................................................


# --------------------------------------
  Sub BlendGcmEcmwfRestarts4Fcst_()
# -------------------------------------
  if ( $?ECHO___ ) set echo

  if (! $?RUN_OPT_BLEND ) then
    echo "RUN_OPT_BLEND must be set in script for restart blending"
    exit 97
  endif

  /bin/ls -l
  set three_hrs_sec = 10800 # three-hours in secs
  set dtg = ( `rst_date d_rst` )
  set dtg = ( `tick $dtg $three_hrs_sec ` )
  set nymd = ${dtg[1]}
  set nhms = ${dtg[2]}
  set hour = `echo ${dtg[2]} | cut -c1-2`
  set ecmwfeta_ana_file = `echorc.x -template $EXPID $dtg[1] $dtg[2] -rc blendrs.rc ecmwfeta_ana_file`

  ecmwf2geos.pl -prs $dtg[1] $dtg[2]
     if ( -e   $ecmwfeta_ana_file ) then
        ln -sf $ecmwfeta_ana_file ana4replay.eta.{$dtg[1]}_${hour}z.$NCSUFFIX
     else
       echo "Failed in ecmwf2geos.pl failed - Aborting ..."
       exit 97
     endif

                              # Last line of BlendGcmEcmwfRestarts4Fcst_()
\end

#.............................................................................

# -------------------------------------
  Sub BlendGcmG5Restarts4Fcst_()
# -------------------------------------
  if ( $?ECHO___ ) set echo

  /bin/ls -l
  set dtg = ( `rst_date d_rst` )
  set nymd = ${dtg[1]}
  set nhms = ${dtg[2]}
  set hour = `echo ${dtg[2]} | cut -c1-2`

  if ( $?FVSPOOL ) then
     set spool = $FVSPOOL
  else        
     set diren = `dirname $FVHOME`
     set spool = $diren/spool
  endif
  
  if (`uname -n` !~ borg*) then
  
       acquire -v -rc blend.acq -s $spool -d . -strict $nymd $nhms 060000 1
       
  else

       set qsub_acquire = 1

        if (`uname -n` =~ borg*) then
           set data_queue=datamove
        else if (`uname -n` =~ r*i[0-3]n*) then
           set data_queue=normal
        else
           set data_queue=""
        endif


        set fname = "acqblend.pbs"
        set acqdate = ${nymd}_`echo $nhms | cut -c1-2`z
        set acqlog = $FVHOME/run/acqblend.log.$acqdate.txt
        fname1 "#\!/bin/csh -xvf"
        fname2 "#$group_list"
        fname2 "#SBATCH --job-name=acqblend"
        fname2 "#SBATCH --output=acqblend.log.$acqdate.txt"
        fname2 "#SBATCH --ntasks=1"
        fname2 "#SBATCH --time=2:00:00"
        fname2 "#SBATCH --partition=$data_queue"
        fname2 "#SBATCH --account=$GID"
        fname2 "#PBS -N acqblend"
        fname2 "#PBS -o acqblend.log.$acqdate.txt"
        fname2 "#PBS -l nodes=1:ppn=1"
        fname2 "#PBS -l walltime=2:00:00"
        fname2 "#PBS -q $data_queue"
        fname2 "#PBS -S /bin/csh"
        fname2 "#PBS -j eo"
        fname2 ""
        fname2 "setenv DO_DMGET $DO_DMGET"
        fname2 "set path = ( $path )"
        fname2 "cd $FVWORK"
        fname2 " acquire -v -rc blend.acq -s $spool -d . -strict $nymd $nhms 060000 1 "
        fname2 "exit"

        if ( $BATCH_SUBCMD == "sbatch" ) then
           sbatch -W -o $acqlog $fname
        else
           qsub -W block=true -o $acqlog $fname
        endif

  endif

  set geos_anal = `echorc.x -template $ANAID $nymd $nhms upper-air_ana_filename`
  if ( ! -e "$geos_anal" ) then
     echo "Missing file - Check $geos_anal"
     exit 97
  endif

  $RUN_OPT_BLEND -divr -ana $geos_anal \
                 -dynrst fvcore_internal_restart \
                 -moistrst moist_internal_restart \
                 -nymd $nymd -nhms $nhms \
                 -topo topo_dynave.data
 
  set dyn_status = $status
  if ( $dyn_status )  then
      exit 97
  else
       ls -l
       /bin/mv -f ./fvcore_internal_restart.ana.${nymd}_${hour}z ./fvcore_internal_rst
       /bin/mv -f ./moist_internal_restart.ana.${nymd}_${hour}z  ./moist_internal_rst
       /bin/cp    ./fvcore_internal_rst $EXPID.fvcore_internal_rst.ana.$itime.$RSTSUFFIX &
       /bin/cp    ./moist_internal_rst  $EXPID.moist_internal_rst.ana.$itime.$RSTSUFFIX &
  endif

                              # Last line of BlendGcmG5Restarts4Fcst_()
\end

#.............................................................................
# -------------------------------------
  Sub CreateIAUincrement4Fcst_()
# -------------------------------------
  if ( $?ECHO___ ) set echo

     if ( ! $DO4DIAU ) then
        if ( -e agcm_import_rst ) exit 0  # no need to regenerate IAU increment if already available
     endif

     set agcmfn = `echorc.x -template $EXPID $dtg iau_tendency_filename`
     if ( -e $fcstage/stage/$agcmfn ) then
        ln -sf $fcstage/stage/$agcmfn agcm_import_rst
        if ( ! $DO4DIAU ) exit 0
     endif

     set initref = ( `tick $dtg 10800` ) # tick clock three hours ahead of RST time

     if ( ! -e fcst.acq ) then
          echo $myname": cannot find fcst.acq file"
          echo $myname": saving  abnormal logs to ${FVHOME}/run"
          echo $myname": abnormal exit from fvpsas, bye, bye..."
          exit 4
     endif

     if ( $?MPIRUN_IAU ) then
          set makeiaux = ( $MPIRUN_IAU ) 
     else 
          echo $myname": env MPIRUN_IAU undefined, cannot run makeiau.x "
          echo $myname": saving  abnormal logs to ${FVHOME}/run"
          echo $myname": abnormal exit from fvpsas, bye, bye..."
          exit 94
     endif

     if ( $?FVSPOOL ) then
        set spool = $FVSPOOL
     else
        set diren = `dirname $FVHOME`
        set spool = $diren/spool
     endif

     if ( $DO4DIAU ) then
        set fcstacq_freq = 010000
        set fnymdb = $GcmBegDate
        set fnhmsb = $GcmBegTime
        set nfcst  = 6
     else
        set fcstacq_freq = 060000
        set fnymdb = $initref[1]
        set fnhmsb = $initref[2]
        set nfcst  = 1
     endif

     # end of IAU-period:
     @ timeinc_sec = $TIMEINC * 60
     set beg_ana   = ( $fnymdb $fnhmsb )
     set end_ana   = ( `tick $fnymdb $fnhmsb $timeinc_sec` )

     if (`uname -n` !~ borg*) then

       acquire -v -rc fcst.acq -s $spool -d . $fnymdb $fnhmsb $fcstacq_freq $nfcst

     else
       set qsub_acquire = 1

        if (`uname -n` =~ borg*) then
           set data_queue=datamove
        else if (`uname -n` =~ r*i[0-3]n*) then
           set data_queue=normal
        else
           set data_queue=""
        endif

        set fname = "acqfcst.pbs"
        set acqdate = ${initref[1]}_`echo $initref[2] | cut -c1-2`z
        set acqlog = $FVHOME/fcst/acqfcst.log.$acqdate.txt
        fname1 "#\!/bin/csh -xvf"
        fname2 "#$group_list"
        fname2 "#SBATCH --job-name=acqfcst"
        fname2 "#SBATCH --output=acqfcst.log.$acqdate.txt"
        fname2 "#SBATCH --ntasks=1"
        fname2 "#SBATCH --time=2:00:00"
        fname2 "#SBATCH --partition=$data_queue"
        fname2 "#$DATAMOVE_CONSTRAINT"
        fname2 "#SBATCH --account=$GID"
        fname2 "#PBS -N acqfcst"
        fname2 "#PBS -o acqfcst.log.$acqdate.txt"
        fname2 "#PBS -l nodes=1:ppn=1"
        fname2 "#PBS -l walltime=2:00:00"
        fname2 "#PBS -q $data_queue"
        fname2 "#PBS -S /bin/csh"
        fname2 "#PBS -j eo"
        fname2 ""
        fname2 "setenv DO_DMGET $DO_DMGET"
        fname2 "set path = ( $path )"
        fname2 "cd $FVWORK"
        fname2 " acquire -v -rc   fcst.acq -s $spool -d . $fnymdb $fnhmsb $fcstacq_freq $nfcst "
        if(-e xinc.acq) then
        fname2 " acquire -v -rc   xinc.acq -s $spool -d . $fnymdb $fnhmsb 060000 1 "
        endif
        if(-e fcst09.acq) then
        fname2 " acquire -v -rc fcst09.acq -s $spool -d . $end_ana[1] $end_ana[2] $fcstacq_freq $nfcst "
        endif
        if(-e fcst03.acq) then
        fname2 " acquire -v -rc fcst03.acq -s $spool -d . $beg_ana[1] $beg_ana[2] $fcstacq_freq $nfcst "
        endif
        fname2 "exit"
                                                                                                          
        if ( $BATCH_SUBCMD == "sbatch" ) then
           sbatch -W -o $acqlog $fname
        else
           qsub -W block=true -o $acqlog $fname
        endif

     endif

     if ( $DO4DIAU ) then
 
        # make sure analysis at end of interval is the same as original from Var corresponding to 
        # proper cycle (i.e., account for fact that DAS cycle overwrites analysis at end of interval)
        if ( -e fcst09.acq ) then
           set ana09upa  = `echorc.x -template $EXPID $end_ana[1] $end_ana[2] upper-air_ana09_filename`
           set ana_upa   = `echorc.x -template $EXPID $end_ana[1] $end_ana[2] upper-air_ana_filename`
           if ( -e $ana09upa ) then
              if ( -e $ana09upa ) then
                 echo "Replacing cycle-overwritten ana.eta w/ original ana.eta consistent w/ current forecast"
                 /bin/mv $ana09upa $ana_upa
              else
                 echo "*************************************************************"
                 echo "WARNING: Unable to find $ana09upa should be checked carefully"
                 echo "WARNING: Unable to find $ana09upa should be checked carefully"
                 echo "WARNING: Unable to find $ana09upa should be checked carefully"
                 echo "*************************************************************"
              endif
           endif
           set iau09inc  = `echorc.x -template $EXPID $end_ana[1] $end_ana[2] iau09_tendency_filename`
           set iau_inc   = `echorc.x -template $EXPID $end_ana[1] $end_ana[2] iau_tendency_filename`
           if ( -e $iau09inc ) then
              if ( -e $iau09inc ) then
                 echo "Replacing cycle-overwritten agcm_import w/ original agcm_import consistent w/ current forecast"
                 /bin/mv $iau09inc $iau_inc
              else
                 echo "*************************************************************"
                 echo "WARNING: Unable to find $iau09inc should be checked carefully"
                 echo "WARNING: Unable to find $iau09inc should be checked carefully"
                 echo "WARNING: Unable to find $iau09inc should be checked carefully"
                 echo "*************************************************************"
              endif
           endif
        endif

        foreach fn ( `ls *.agcmrst*tar` )
           tar xvf $fn
        end 

        foreach fn (`ls *.agcm_import_rst.*`)
            set noexpid = `echo $fn | cut -d. -f2-`
            /bin/ln -s  $fn $noexpid
        end
        set agcmfn = `echorc.x -template $EXPID $fnymdb $fnhmsb iau_tendency_filename`
        ln -sf $agcmfn agcm_import_rst

        set lstfn = `ls *incrst*tar`
        if (! $status ) then
           tar xvf $lstfn
           /bin/rm $lstfn
        endif

     else

        set agcmfn = `echorc.x -template $EXPID $initref[1] $initref[2] iau_tendency_filename`
        if ( -e $agcmfn ) then
           ln -sf $agcmfn agcm_import_rst
           exit 0
        endif

        set bkg06fn  = `echorc.x -template $EXPID $initref[1] $initref[2] upper-air_bkg06_filename`
        set bkgfile  = `echorc.x -template $EXPID $initref[1] $initref[2] upper-air_bkg_filename`
        if ( -e $bkg06fn ) then
           set bkg4ainc = $bkg06fn
        else
           set bkg4ainc = $bkgfile
        endif

        set ana4ainc  = `echorc.x -template $EXPID $initref[1] $initref[2] upper-air_ana_filename`
        set ifile     = `echorc.x -template $EXPID $initref[1] $initref[2] upper-air_inc_filename`

        if ( ! -e $bkg4ainc ) then
             /bin/cp fvpsas.log  ${FVHOME}/run/fvpsas.abnormal.log
             echo $myname": cannot find background file"
             echo $myname": saving  abnormal logs to ${FVHOME}/run"
             echo $myname": abnormal exit from fvpsas, bye, bye..."
             exit 4
        endif

        if ( ! -e $ana4ainc ) then
             /bin/cp fvpsas.log  ${FVHOME}/run/fvpsas.abnormal.log
             echo $myname": cannot find background file"
             echo $myname": saving  abnormal logs to ${FVHOME}/run"
             echo $myname": abnormal exit from fvpsas, bye, bye..."
             exit 4
        endif

     
        if ( -e mkiau.rc.tmpl ) then
      
            /bin/rm -f sed_file
            echo "s/>>>EXPID<<</${EXPID}/1"         > sed_file
            echo "s/>>>BKGFNAME<<</${bkg4ainc}/1"  >> sed_file
            echo "s/>>>ANAFNAME<<</${ana4ainc}/1"  >> sed_file
            echo "s/>>>NCSUFFIX<<</${NCSUFFIX}/1"  >> sed_file
            echo "s/>>>ANADATE<<</${initref[1]}/1" >> sed_file
            echo "s/>>>ANATIME<<</${initref[2]}/1" >> sed_file
            /bin/rm -f ./mkiau.rc
            sed -f sed_file  ./mkiau.rc.tmpl  > ./mkiau.rc
            $makeiaux

        else

            set imout = `grep AGCM_IM: AGCM.rc.tmpl | cut -d : -f2`
            set jmout = `grep AGCM_JM: AGCM.rc.tmpl | cut -d : -f2`
            $makeiaux -ana $ana4ainc -bkg $bkg4ainc \
                      -imout $imout -jmout $jmout \
                      -divr -iau agcm_import_rst \
                      -nymd $initref[1] -nhms $initref[2]
                                                                                               
        endif
        if ( -e IAU_EGRESS ) then
           echo "IAU increment generated"
           /bin/rm -f IAU_EGRESS  # clean up and move on
        else
           echo "Failed to generate IAU increment"
           set status = 1
        endif
        if ( ${status} ) then
           Call AbnormalExit_ ( 4 )
        endif

        if ( ! -e $ifile ) then
           dyn_recenter.x -g5 $ana4ainc $bkg4ainc NONE -o $ifile
        endif

     endif # <DO4DIAU>

                              # Last line of CreateIAUincrement4Fcst_()
\end
#.............................................................................
# -------------------------------------
  Sub GetAODinfo4Fcst_()
# -------------------------------------
  if ( $?ECHO___ ) set echo

     if (! $GAASFDBK ) exit 0

     if (! -e aod4fcst.acq ) exit 0  # no need to regenerate IAU increment if already available

     set initref = ( `tick $dtg 10800` ) # tick clock three hours ahead of RST time

     if ( $?FVSPOOL ) then
        set spool = $FVSPOOL
     else
        set diren = `dirname $FVHOME`
        set spool = $diren/spool
     endif

     if (`uname -n` !~ borg*) then

       acquire -v -rc aod4fcst.acq -s $spool -d . -strict $initref[1] $initref[2] 030000 2

     else
        set qsub_acquire = 1

        if (`uname -n` =~ borg*) then
           set data_queue=datamove
        else if (`uname -n` =~ r*i[0-3]n*) then
           set data_queue=normal
        else
           set data_queue=""
        endif

        set fname = "acqaod4fcst.pbs"
        set acqdate = ${initref[1]}_`echo $initref[2] | cut -c1-2`z
        set acqlog = $FVHOME/fcst/acqaod4fcst.log.$acqdate.txt
        fname1 "#\!/bin/csh -xvf"
        fname2 "#$group_list"
        fname2 "#SBATCH --job-name=acqaod4fcst"
        fname2 "#SBATCH --output=acqaod4fcst.log.$acqdate.txt"
        fname2 "#SBATCH --ntasks=1"
        fname2 "#SBATCH --time=2:00:00"
        fname2 "#SBATCH --partition=$data_queue"
        fname2 "#$DATAMOVE_CONSTRAINT"
        fname2 "#SBATCH --account=$GID"
        fname2 "#PBS -N acqaod4fcst"
        fname2 "#PBS -o acqaod4fcst.log.$acqdate.txt"
        fname2 "#PBS -l nodes=1:ppn=1"
        fname2 "#PBS -l walltime=2:00:00"
        fname2 "#PBS -q $data_queue"
        fname2 "#PBS -S /bin/csh"
        fname2 "#PBS -j eo"
        fname2 ""
        fname2 "setenv DO_DMGET $DO_DMGET"
        fname2 "set path = ( $path )"
        fname2 "cd $FVWORK"
        fname2 " acquire -v -rc aod4fcst.acq -s $spool -d . -strict $initref[1] $initref[2] 030000 2 "
        fname2 "exit"
                                                                                                          
        if ( $BATCH_SUBCMD == "sbatch" ) then
           sbatch -W -o $acqlog $fname
        else
           qsub -W block=true -o $acqlog $fname
        endif

     endif

                              # Last line of GetAODinfo4Fcst_()
\end
#.............................................................................

# ------------------------------
  Sub CopyAnaRestarts_()
# ------------------------------
  if ( $?ECHO___ ) set echo

     @ nbkgfiles = $TIMEINC / $ASYNBKG + 1
     if(! $DOIAU ) set nbkgfiles = 1
     @ nbkgtotal = 2 * $nbkgfiles 

     set upa_brs_list = `ls $FVHOME/recycle/$EXPID.bkg*eta*.$NCSUFFIX`
     set sfc_brs_list = `ls $FVHOME/recycle/$EXPID.bkg*sfc*.$NCSUFFIX`

     if ( ( ! -e $FVHOME/run/replay.acq ) && ( ( $#upa_brs_list < $nbkgfiles ) || ( $#sfc_brs_list < $nbkgfiles ) ) ) then
            echo $myname": cannot acquire background files from $FVHOME/recycle/"
             if ( $log ) then
                  Err_Log.pl -N ${EXPID}.j -I $ERROR_ID -X $ERROR_EXP -C 90 \
                             -E 5 $ERROR_LOG_NAME \
                             -D "${EXPID}.j FATAL ERROR: $myname cannot acquire background files from $FVHOME/recycle/"
             endif
             exit 90
     endif

     if ( $DO4DVAR ) then
        set thisrc = GSI_GridComp_1.rc.tmpl
     else
        set thisrc = GSI_GridComp.rc.tmpl
     endif

     # check for need of chemistry bkg file (any date below)
     #------------------------------------------------------
     set dummy = `echorc.x -rc $thisrc -template $EXPID 17760704 00000 chem_bkg_filename`
     if ( ! ($dummy == "NONE") ) then
        set chm_brs_list = `ls $FVHOME/recycle/$EXPID.cbkg*eta*.$NCSUFFIX`
        if ( ( ! -e $FVHOME/run/replay.acq ) && ( $#chm_brs_list < $nbkgfiles ) ) then
               echo $myname": cannot acquire chem background files from $FVHOME/recycle/"
                if ( $log ) then
                     Err_Log.pl -N ${EXPID}.j -I $ERROR_ID -X $ERROR_EXP -C 90 \
                                -E 5 $ERROR_LOG_NAME \
                                -D "${EXPID}.j FATAL ERROR: $myname cannot acquire chem background files from $FVHOME/recycle/"
                endif
                exit 90
        endif
     endif

     # check for need of aerosols bkg file (any date below)
     #-----------------------------------------------------
     set dummy = `echorc.x -rc $thisrc -template $EXPID 17760704 00000 aero_bkg_filename`
     if ( ! ($dummy == "NONE") ) then
        set aer_brs_list = `ls $FVHOME/recycle/$EXPID.abkg*eta*.$NCSUFFIX`
        if ( ( ! -e $FVHOME/run/replay.acq ) && ( $#aer_brs_list < $nbkgfiles ) ) then
               echo $myname": cannot acquire aero background files from $FVHOME/recycle/"
                if ( $log ) then
                     Err_Log.pl -N ${EXPID}.j -I $ERROR_ID -X $ERROR_EXP -C 90 \
                                -E 5 $ERROR_LOG_NAME \
                                -D "${EXPID}.j FATAL ERROR: $myname cannot acquire aero background files from $FVHOME/recycle/"
                endif
                exit 90
        endif
     endif

     set ars_list = ( satbias satbang )
     if ($NEWRADBC || $ANGLEBC) then
       set ars_list = ( $ars_list satbiaspc )
     endif
     if ($ACFTBIAS) then
       set ars_list = ( $ars_list acftbias )
     endif

     foreach rs ( $ars_list )
         /bin/cp $FVHOME/recycle/$EXPID.ana_${rs}_rst.*.txt ./$rs 
         if ( ( $status ) && ( ! $BOOTSTRAP ) ) then
             echo $myname": cannot acquire $FVHOME/recycle/$EXPID.ana_${rs}_rst"
             if ( $log ) then
                  Err_Log.pl -N ${EXPID}.j -I $ERROR_ID -X $ERROR_EXP -C 90 \
                             -E 5 $ERROR_LOG_NAME \
                             -D "${EXPID}.j FATAL ERROR: $myname cannot acquire $FVHOME/recycle/$EXPID.ana_${rs}_rst"
             endif
             exit 90
         endif
     end

     if ( $ANGLEBC && $DIAGTAR ) then
       /bin/cp $FVHOME/recycle/$EXPID.ana_radstat_rst.*.tar radstat
     endif

     # GAAS restart files
     #-------------------
     if ( ! $DO4DVAR ) then
       if ( $GAAS_ANA && ( ! -e $FVHOME/run/gaas/GAAS.BOOTSTRAP ) ) then
          set gaas_brs_list = `ls $FVHOME/recycle/$EXPID.gaas_bkg_sfc_rst*.$NCSUFFIX`
          if ( ( $status ) || ( $#gaas_brs_list != 2 ) ) then
             echo $myname": cannot acquire $FVHOME/recycle/$EXPID.gaas_bkg_sfc_rst"
             if ( $log ) then
                  Err_Log.pl -N ${EXPID}.j -I $ERROR_ID -X $ERROR_EXP -C 90 \
                             -E 5 $ERROR_LOG_NAME \
                             -D "${EXPID}.j FATAL ERROR: $myname cannot acquire $FVHOME/recycle/$EXPID.gaas_bkg_sfc_rst"
             endif
             exit 90
          endif

          foreach rs ( $gaas_brs_list )
             set fvdate = (`fndate.pl $rs`)
             set bkgfile = `echorc.x -template $EXPID $fvdate[1] $fvdate[2] gaas_bkg_filename`
             /bin/cp $rs $bkgfile
             if ( $status ) then
                echo $myname": failed to copy $FVHOME/recycle/$EXPID.gaas_bkg_sfc_rst"
                if ( $log ) then
                     Err_Log.pl -N ${EXPID}.j -I $ERROR_ID -X $ERROR_EXP -C 90 \
                                -E 5 $ERROR_LOG_NAME \
                                -D "${EXPID}.j FATAL ERROR: $myname failed to copy $FVHOME/recycle/$EXPID.gaas_bkg_sfc_rst"
                endif
                exit 90
             endif
          end
       endif        
     endif # <DO4DVAR>

     foreach rs ( $sfc_brs_list )
          set fvdate = (`fndate.pl $rs`)
          set bkgfile  = `echorc.x -template $EXPID $fvdate[1] $fvdate[2] surface_bkg_filename`
         /bin/cp ${rs} $bkgfile &
     end
     foreach rs ( $upa_brs_list )
          set fvdate = (`fndate.pl $rs`)
          set bkgfile  = `echorc.x -template $EXPID $fvdate[1] $fvdate[2] upper-air_bkg_filename`
         /bin/cp ${rs} $bkgfile &
     end
     if ( $?chm_brs_list ) then
         foreach rs ( $chm_brs_list )
              set fvdate = (`fndate.pl $rs`)
              set bkgfile  = `echorc.x -template $EXPID $fvdate[1] $fvdate[2] chem_bkg_filename`
             /bin/cp ${rs} $bkgfile &
         end
     endif
     if ( $?aer_brs_list ) then
         foreach rs ( $aer_brs_list )
              set fvdate = (`fndate.pl $rs`)
              set bkgfile  = `echorc.x -template $EXPID $fvdate[1] $fvdate[2] aero_bkg_filename`
             /bin/cp ${rs} $bkgfile &
         end
     endif
     wait

     set brs_list = `ls $EXPID.bkg*.$NCSUFFIX`  # redefine bkg rst list

     if(-e $FVHOME/recycle/$EXPID.biasinp_rst.$itime.ctl ) then
         /bin/cp $FVHOME/recycle/$EXPID.biasinp_rst.$itime.ctl   biasinp.ctl &
     endif
     if ( -e $FVHOME/recycle/$EXPID.biasinp_rst.$itime.$RSTSUFFIX ) then
         /bin/cp $FVHOME/recycle/$EXPID.biasinp_rst.$itime.$RSTSUFFIX   biasinp.$RSTSUFFIX &
     endif

     if ( ( ! -e $FVHOME/run/replay.acq ) && ( $#brs_list < $nbkgtotal ) ) then
              echo $myname": cannot acquire background files from $FVHOME/recycle/"
             if ( $log ) then
                  Err_Log.pl -N ${EXPID}.j -I $ERROR_ID -X $ERROR_EXP -C 90 \
                             -E 5 $ERROR_LOG_NAME \
                             -D "${EXPID}.j FATAL ERROR: $myname cannot acquire background files from $FVHOME/recycle/"
             endif
             exit 90
     endif 
     set gda_file = `ls $FVHOME/recycle/$EXPID.trak.GDA.rst.*.txt`
     if ( ! $status ) then
          /bin/cp $gda_file  .
          set trksufx = `echo $gda_file:t | cut -d. -f5,6`
          /bin/mv $EXPID.trak.GDA.rst.*.txt $EXPID.trak.GDA.all.$trksufx
          if ( ( $status ) || ( ! -e $EXPID.trak.GDA.all.$trksufx ) || ( -z $EXPID.trak.GDA.all.$trksufx ) ) then
             echo $myname": cannot acquire $gda_file"
             if ( $log ) then
                  Err_Log.pl -N ${EXPID}.j -I $ERROR_ID -X $ERROR_EXP -C 90 \
                             -E 5 $ERROR_LOG_NAME \
                             -D "${EXPID}.j FATAL ERROR: $myname cannot acquire $gda_file"
             endif
             exit 90
          endif
     endif

     if ( $DO4DVAR ) then           # no need to refer to traj otherwise
        set trjdate = ( `rst_date d_rst` )
        set trajfile1 = `echorc.x -template $EXPID $trjdate[1] $trjdate[2] uparst_traj_filename`
        set trajfile2 = `echorc.x -template $EXPID $trjdate[1] $trjdate[2] upalcv_traj_filename`
        /bin/cp $FVHOME/recycle/$trajfile1  $trajfile2
#       set ptrjfile1 = `echorc.x -template $EXPID $trjdate[1] $trjdate[2] uparst_ptrj_filename`
#       set ptrjfile2 = `echorc.x -template $EXPID $trjdate[1] $trjdate[2] upaprs_traj_filename`
#       /bin/cp $FVHOME/recycle/$ptrjfile1  $ptrjfile2
     endif

                              # Last line of CopyAnaRestarts_() 
\end

#.............................................................................

# ------------------------------------
  Sub DetermineSimulationTimes_()
# ------------------------------------
  if ( $?ECHO___ ) set echo

# Unlikely to change (anytime soon) variables
# -------------------------------------------
 setenv ANAFREQ     $TIMEINC # analysis frequency (e.g., every 360 min)
 setenv ANATIME     $TIMEINC # analysis time is 6-hr from initial time of forecast (not counting offset)
 setenv OBSWINDOW   360      # time window of observations: bufr files are 6-hr files for now

# Get end of simulation date/time from namelist
# ---------------------------------------------
 if ($ihh0 >= 0) then
    set mycap = CAP_${ihh0}.rc.tmpl
 else
    set mycap = CAP.rc.tmpl
 endif
 set nymde     =   `grep -i end_date $mycap|awk '{printf "%d", $2}'`
 set nhmse     =   `grep -i end_date $mycap|awk '{printf "%d", $3}'`
 set nd_nh     = ( `grep -i JOB_SGMT $mycap|awk '{printf "%d %d",$2, $3}'` )
 if ( ($?ANAFREQ) && !(-e replay.acq) ) then
       @ afreqhr = $ANAFREQ   / 60           # analysis freq in hours
       @ afreqsc = $ANAFREQ   * 60           # analysis in seconds
       set buf   = `tick 20010101 000000 $afreqsc`  # just a trick to get nhmsa w/o ref to fvpsasdt
       set nhmsa = $buf[2]       
 else
       @ afreqhr = $ANAFREQ   / 60           # analysis freq in hours
       @ afreqsc = $ANAFREQ   * 60           # analysis in seconds
       @ nhmsa   = $afreqhr * 10000
 endif    

 @ anatime_hrs    = $ANATIME    / 60
 @ dtasyn_hrs     = $ASYNBKG    / 60
 @ obstwindow_hrs = $OBSWINDOW  / 60
 @ aoffset_hrs    = $VAROFFSET  / 60;   @ aoffset_sec    = $VAROFFSET  * 60
 @ varwindow_hrs  = $TIMEINC    / 60;   @ varwindow_sec  = $TIMEINC    * 60

 if ( $aoffset_hrs == 0 ) then
      @ bkgbits0      = $anatime_hrs   - $obstwindow_hrs / 2;
      @ bkgbitsf      = $varwindow_hrs + $obstwindow_hrs / 2;
 else
      @ bkgbits0      = $anatime_hrs   - $aoffset_hrs;
      @ bkgbitsf      = $varwindow_hrs + $aoffset_hrs;
 endif
 @ bkgbits0_sec  = $bkgbits0 * 3600

# Get the starting date/time for this segment
# -------------------------------------------
  set buf  = `rst_date d_rst`
  set nymd1g = $buf[1]
  set nhms1g = $buf[2]
  set buf = `tick $nymd1g $nhms1g $aoffset_sec`
  set nymd1 = $buf[1]
  set nhms1 = $buf[2]
  @ hour1 = $nhms1 / 10000
  if ( $hour1 < 10 ) set hour1 = 0$hour1

 set fcs_nymdi = 22000101  # dummy date
 set fcs_nhmsi = 000000    # dummy time

 if ( $MKRESRST ) then
        set fcst_beg = ( `rst_date d_rst` )
        set nymdt   = $fcst_beg[1]
        set nhmst   = $fcst_beg[2]
        set nd_nh = ( `grep -i JOB_SGMT $mycap | awk '{printf "%d %d",$2, $3}'` )
        set nsecs = `(expr $nd_nh[1] \* 86400 \+ $nd_nh[2] \/ 10000 \* 3600)`
        set fcst_end = ( `tick $fcst_beg $nsecs` )
   endif

                              # Last line of DetermineSimulationTimes_ 
\end
   
#.............................................................................

# ----------------------------------------------------------------
  Sub DetermineExpTimes_ ( _ExpEndEpoch )
# ----------------------------------------------------------------
  if ( $?ECHO___ ) set echo

  if ($ihh0 >= 0 ) then
     set $_ExpEndEpoch = (`grep -i end_date CAP_${ihh0}.rc.tmpl|awk '{print $2 $3}'`)
  else
     set $_ExpEndEpoch = (`grep -i end_date CAP.rc.tmpl|awk '{print $2 $3}'`)
  endif

                                        # Last line of DetermineExpTimes_   

\end
   
#.............................................................................

# -------------------------------------------------------------------
  Sub DetermineGcmTimes_ ( _GcmBegEpoch, _GcmEndEpoch, _GcmLenEpoch )  
# -------------------------------------------------------------------
  if ( $?ECHO___ ) set echo

  set GcmBegEpoch_ = ( `rst_date d_rst` )
  if ($ihh0 >= 0 ) then
     set GcmLenEpoch_ = `grep "^JOB_SGMT:" CAP_${ihh0}.rc.tmpl | cut -d: -f2` 
  else
     set GcmLenEpoch_ = `grep "^JOB_SGMT:" CAP.rc.tmpl | cut -d: -f2` 
  endif

# Return results by reference
# ---------------------------
  set $_GcmBegEpoch = ( $GcmBegEpoch_ )
  set $_GcmLenEpoch = ( $GcmLenEpoch_ )
  set $_GcmEndEpoch = ( `tick $GcmBegEpoch_ $GcmLenEpoch_` )

                              # Last line of DetermineGcmTimes_   
\end
   
# -------------------------------------------------------------------
  Sub DetermineTrjTimes_ ( _TrjBegEpoch, _TrjEndEpoch )
# -------------------------------------------------------------------
  if ( $?ECHO___ ) set echo

  set $_TrjBegEpoch = ( 22000101 000000 )  # default is to never output trajectory
  set $_TrjEndEpoch = ( 22000101 000000 )  # default is to never output trajectory

  set RstNow = `rst_date d_rst`
  set hh = `echo $RstNow[2] | cut -c1-2`

  if ( (! -e fvsens.ccmrun.namelist.tmpl) && (! -e fvsvec.ccmrun.namelist.tmpl) && (! -e fvoseledec.ccmrun.namelist.tmpl) && \
       (! -e fvsens.ccmrun.namelist_${hh}.tmpl) )  exit 0

  @ doit = 0
  if ( -e initadj.rc && -e fvsens.ccmrun.namelist.tmpl ) then
      @ doit = $doit + 1
  endif
  if ( -e initadj.rc && -e fvsens.ccmrun.namelist_${hh}.tmpl ) then
      @ doit = $doit + 1
  endif
  if ( -e  fvsvec.rc && -e fvsvec.ccmrun.namelist.tmpl ) then
      @  doit = $doit + 1
  endif
  if ( -e  oseledec.rc && -e fvoseledec.ccmrun.namelist.tmpl ) then
      @  doit = $doit + 1
  endif

  if ( ! $doit ) exit 0


# The following are calculated in DetermineGcmTimes but main script has 
# this call placed too late for forecast applications to grab information!
# -----------------------------------------------------------------------
  set FcsBegEpoch = ( $RstNow )
  if ( $ifcst || $DOIAU ) then
      set FcsBegEpoch = ( `tick $FcsBegEpoch  $foffset_sec` )  # tick clock 3hrs forward
  endif
  if ( $ihh0 >= 0) then
     set mycap = CAP_${ihh0}.rc.tmpl
  else
     set mycap = CAP.rc.tmpl
  endif
  set FcsLenEpoch = ( `grep -i JOB_SGMT $mycap|awk '{printf "%d %d",$2, $3}'` )
  set FcsLenSecs  = `(expr $FcsLenEpoch[1] \* 86400 \+ $FcsLenEpoch[2] \/ 10000 \* 3600)`
  if ( $ifcst || $DOIAU ) then
      @ FcsLenSecs = $FcsLenSecs - $foffset_sec  # subtract 3hr from actual forecast length when
                                                 # fcst started w/ 3hr offset
  endif
  set FcsEndEpoch = ( `tick $FcsBegEpoch $FcsLenSecs` )

  @ nlagmin =  9999
  @ nlagmax = -1
  @ nintmax = -1
  foreach fn ( fvsens.ccmrun.namelist.tmpl fvsvec.ccmrun.namelist.tmpl fvoseledec.ccmrun.namelist.tmpl \
               fvsens.ccmrun.namelist_${hh}.tmpl )
  if ( -e $fn ) then

     if ( -e fcstrules.rc ) then
          set fini_hrs = `echorc.x -rc fcstrules.rc forecast_initial_hour`
          set lags_hrs = `echorc.x -rc fcstrules.rc integration_time_lag_start_hrs`
          set this_fcst_hr = `echo $FcsBegEpoch[2] | cut -c1-2`
          @ lag_hrs = -1
          set nlag = $#lags_hrs
          set nv = 0
          while ( $nv < $nlag )   # determine syn hr to start PERT integration
            @ nv++
            if ( $this_fcst_hr == $fini_hrs[$nv] ) set lag_hrs = $lags_hrs[$nv]
          end
          if ( $lag_hrs == -1 ) then
                Err_Log.pl -N ${EXPID}.job.${bnymd} -C 99 \
                           -I $ERROR_ID -X $ERROR_EXP -E 5 $ERROR_LOG_NAME \
                           -D "${EXPID}.job.${bnymd} FATAL ERROR: $myname cannot determine time lag for PERT integration"
          endif

          # Against all rules, edit template file and overwrite it (rendering template half-way useless)
          # --------------------------------------------------------------------------------------------
          /bin/rm -f sed_file
          /bin/mv $fn $fn.tmp
          echo "s/>>>ADMBEGTLAG<<</${lag_hrs}/1"  > sed_file # actual date to write rst
          sed -f sed_file  ./$fn.tmp   > ./$fn
     endif

     set lag_hrs = `echorc.x -rc $fn integration_time_lag_start_hrs`
     set int_hrs = `echorc.x -rc $fn integration_length_hrs`
     set nlag = $#lag_hrs
     set nv = 0
     while ( $nv < $nlag )
       @ nv++
       if ( $lag_hrs[$nv] < $nlagmin ) set nlagmin = $lag_hrs[$nv]
       if ( $lag_hrs[$nv] > $nlagmax ) set nlagmax = $lag_hrs[$nv]
     end
     if ( $int_hrs > $nintmax ) set nintmax = $int_hrs
  endif
  end

  echo " max int time for perturbation applications is $nintmax hrs"
  echo " max lag time for perturbation applications is $nlagmax hrs"  
  echo " min lag time for perturbation applications is $nlagmin hrs"  

  @ nlagmin = $nlagmin * 3600
  @ nlagmax = $nlagmax * 3600
  @ nintmax = $nintmax * 3600 + $nlagmax

# Return results by reference
# ---------------------------
  set   TrjEndEpoch = `tick $FcsEndEpoch  -$nlagmin`
  set   TrjBegEpoch = `tick $FcsEndEpoch  -$nintmax`
  set $_TrjEndEpoch = ( $TrjEndEpoch )
  set $_TrjBegEpoch = ( $TrjBegEpoch )

                              # Last line of DetermineTrjTimes_   
\end
   
#.............................................................................
   
# ----------------------------------------------------------------------------
  Sub DetermineAnaTimes_ ( DoingIAU_, GcmBegDate_, GcmBegTime_, AnaFreqMins_, \
                           _AnaBegEpoch, _AnaFreqEpoch ) 
# ----------------------------------------------------------------------------
  if ( $?ECHO___ ) set echo

# Determine analysis frequency in hhmmss format
# ---------------------------------------------
  @ AnaFreqSecs_  = $AnaFreqMins_ * 60
  @ hh = $AnaFreqSecs_ / 3600
  @ mm = ($AnaFreqSecs_ % 3600) / 60
  @ AnaFreqTime_  = $hh * 10000 + $mm * 100 
  if ( $hh < 10 ) set AnaFreqTime_  = 0$AnaFreqTime_

# Return results by reference
# ---------------------------
  if ( $DoingIAU_ ) then
       @ HalfFreqSecs_ = $AnaFreqSecs_ / 2
       set $_AnaBegEpoch = ( `tick $GcmBegDate_ $GcmBegTime_ $HalfFreqSecs_` )
  else
       set $_AnaBegEpoch = ( $GcmBegDate_ $GcmBegTime_ )
  endif
  set $_AnaFreqEpoch  = ( 00000000 $AnaFreqTime_ )

                              # Last line of DetermineAnaTimes_   
\end
   
#.............................................................................

# ---------------------------------
  Sub DetermineAcquireTimes_()
# ---------------------------------
  if ( $?ECHO___ ) set echo

# if ( $?NSTEP ) then
#       @ nstep   = $NSTEP
# else 
#       @ nstep   = $ndays * 24 / ($nhmsa / 10000)
# endif
# if ( $?NLOOK ) then
#       @ nlook   = $NLOOK
# else 
#       @ nlook   = $nstep 
# endif
# if ( $?FVSPOOL ) then
#    set spool = $FVSPOOL
# else
#    set diren = `dirname $FVHOME`
#    set spool = $diren/spool
# endif

     if ( $?NSTEP ) then
           @ nstep   = $NSTEP
     else 
           @ ntv     = $varwindow_hrs / $obstwindow_hrs             # no. of obs time intervals within var window
           @ nstep   =             24 / $obstwindow_hrs + $ntv - 1  # no. of obs time intervals within one day
     endif
     if ( $?NLOOK ) then
           @ nlook   = $NLOOK
     else 
           @ nlook   = $nstep 
     endif
     if ( $?FVSPOOL ) then
        set spool = $FVSPOOL
     else
        set diren = `dirname $FVHOME`
        set spool = $diren/spool
     endif

     @ nsecs = ($nhmsa / 10000) * 3600
#    set buf = `tick $nymd1 $nhms1 $nsecs`
     set bnymd = $nymd1 # $buf[1]
     set bnhms = $nhms1 # $buf[2]
     set inhms = $nhmsa
     set onhms = 060000 # frequency of observation files (we pack files in 6-hr intervals)
     @ esecs = $nstep * $nsecs
     set enymd=`tick $nymd1g $nhms1g $esecs`

                              # Last line of DetermineAcquireTimes
\end


#.............................................................................

# ---------------------------------
  Sub AcquireReplayAnalysis_()
# ---------------------------------
  if ( $?ECHO___ ) set echo

     if ( (! $?rpl_nymdb) && (! $?rpl_nhmsb)) then
        set rpl_nymdb = $bnymd
        set rpl_nhmsb = $bnhms
     endif

     # Acquire anlysis data for replay locally
     # ----------------------------------------
     if ( (`uname -n` !~ borg*) || ( $LOCAL_ACQUIRE ) ) then
           acquire -v -rc replay.acq -s $spool -d $FVWORK -la $nlook -ssh  \
                      $strict $rpl_nymdb $rpl_nhmsb $inhms $nstep 
     else

        # Do something special when on NCCS linux cluster
        #------------------------------------------------
        if (`uname -n` =~ borg*) then
           set data_queue=datamove
        else if (`uname -n` =~ r*i[0-3]n*) then
           set data_queue=normal
        else
           set data_queue=""
        endif

        set qsub_acquire = 1
        set fname = "acqreplay1.pbs"
        set acqdate = ${bnymd}_`echo $bnhms | cut -c1-2`z
        set acqlog = $FVHOME/run/acqreplay1.log.$acqdate.txt
        @ hours = $ASYNBKG * 60
        set init_date = (`tick $rpl_nymdb $rpl_nhmsb -$hours` )
        fname1 "#\!/bin/csh -xvf"
        fname2 "#$group_list"
        fname2 "#SBATCH --job-name=acqreplay1"
        fname2 "#SBATCH --output=acqreplay1.log.$acqdate.txt"
        fname2 "#SBATCH --ntasks=1"
        fname2 "#SBATCH --time=2:00:00"
        fname2 "#SBATCH --partition=$data_queue"
        fname2 "#$DATAMOVE_CONSTRAINT"
        fname2 "#SBATCH --account=$GID"
        fname2 "#PBS -N acqreplay1"
        fname2 "#PBS -o acqreplay1.log.$acqdate.txt"
        fname2 "#PBS -l nodes=1:ppn=1"
        fname2 "#PBS -l walltime=2:00:00"
        fname2 "#PBS -q $data_queue"
        fname2 "#PBS -S /bin/csh"
        fname2 "#PBS -j eo"
        fname2 ""
        fname2 "setenv DO_DMGET $DO_DMGET"
        fname2 "set path = ( $path )"
        fname2 "cd $FVWORK"
        fname2 "acquire -v -rc replay.acq -s $spool -d $FVWORK -ssh $strict $rpl_nymdb $rpl_nhmsb 060000 1"
        fname2 "if ( -e replay_aod.acq ) then"
        fname2 "   acquire -v -rc replay_aod.acq -s $spool -d $FVWORK -ssh $strict $rpl_nymdb $rpl_nhmsb 030000 2"
        fname2 "endif"
        fname2 "if ( -e replay_agcm.acq ) then"
        fname2 "   acquire -v -rc replay_agcm.acq -s $spool -d $FVWORK -ssh $strict $init_date[1] $init_date[2] 060000 1"
        fname2 "endif"
        fname2 ""
        fname2 "exit"

        if ( $BATCH_SUBCMD == "sbatch" ) then
           sbatch -W -o $acqlog $fname
        else
           qsub -W block=true -o $acqlog $fname
        endif
        sleep 2
        @ cyc_sec = $TIMEINC * 60
        set next_cycle = (`tick $rpl_nymdb $rpl_nhmsb $cyc_sec`)
        set rpl_nymdb = $next_cycle[1]
        set rpl_nhmsb = $next_cycle[2]

     endif # test for borg*

     set anafiles = "`ls -1 *.ana.eta.*.$NCSUFFIX`"
     if ( "$anafiles" == "" ) then
           echo $myname": could not acquire analysis files for replay"
          if ( $log ) then
             Err_Log.pl -N ${EXPID}.job.${bnymd}  -C 99 \
                        -I $ERROR_ID -X $ERROR_EXP -E 5 $ERROR_LOG_NAME \
                        -D "${EXPID}.job.${bnymd} FATAL ERROR: $myname cannot acquire analysis files for replay"
          endif
	  exit 99
       endif
       foreach anafn ( $anafiles )
          set tmp     = $anafn:r
          set timetag = $tmp:e
          set thisana = $EXPID.ana.eta.$timetag.$NCSUFFIX
          if ( "$anafn" != "$thisana" ) /bin/mv $anafn $thisana
       end

                              # Last line of AcquireReplayAnalysis_ 
\end


#.............................................................................

# -------------------------------
  Sub AcquireObservations_() 
# -------------------------------
  if ( $?ECHO___ ) set echo
  set qsub_acquire = 0

  set ecode = 0
  set acq_status = 0
  set acq_status2 = 0

# Check DMF status
# ----------------
  if ( ( $CHECK_DMF ) && ( `uname -n` !~ borg* ) ) then
       set dmf_alive = `cat /archive/input/dao_ops/.DMF_IS_ALIVE`
       if ( "$dmf_alive" != "DMF_IS_ALIVE" ) then
            set ecode = "93"
            set emessage = "FATAL ERROR: DMF appears to be down.  Stopping."
       endif
  endif    

# User provides her own obsys.acq
# -------------------------------
  if ( ( -e "obsys.acq") && ( ! $ecode) ) then
     if (`uname -n` !~ borg*) then

         acquire -v -rc obsys.acq -s $spool -d $FVWORK -la $nlook -ssh  \
                 $strict $bnymd $bnhms $inhms $nstep 
         set acq_status = $status

     else

        # Do something special when on NCCS linux cluster
        #------------------------------------------------
        set qsub_acquire = 1

        if (`uname -n` =~ borg*) then
           set data_queue=datamove
        else if (`uname -n` =~ r*i[0-3]n*) then
           set data_queue=normal
        else
           set data_queue=""
        endif

        if ( $nstep > 4 ) set nstep = 4

        while ( ( $bnymd <= $enymd[1] ) && ( ! -e "${FVWORK}/acquire.FAILED" ) )
             set fname = "acqobs1.pbs"
             set acqdate = ${bnymd}_`echo $bnhms | cut -c1-2`z
             set acqlog = $FVHOME/run/acqobs1.log.$acqdate.txt

             fname1 "#\!/bin/csh -xvf"
             fname2 "#$group_list"
             fname2 "#SBATCH --job-name=acqobs1"
             fname2 "#SBATCH --output=acqobs1.log.$acqdate.txt"
             fname2 "#SBATCH --ntasks=1"
             fname2 "#SBATCH --time=2:00:00"
             fname2 "#SBATCH --partition=$data_queue"
             fname2 "#SBATCH --account=$GID"
             fname2 "#PBS -N acqobs1"
             fname2 "#PBS -o acqobs1.log.$acqdate.txt"
             fname2 "#PBS -l nodes=1:ppn=1"
             fname2 "#PBS -l walltime=2:00:00"
             fname2 "#PBS -q $data_queue"
             fname2 "#PBS -S /bin/csh"
             fname2 "#PBS -j eo"
             fname2 ""
             fname2 "setenv DO_DMGET $DO_DMGET"
             fname2 "set path = ( $path )"
             fname2 "cd $FVWORK"
             fname2 "acquire -v -rc obsys.acq -s $spool -d $FVWORK -ssh $strict $bnymd $bnhms $inhms 4"
             fname2 "exit"

             if ( $BATCH_SUBCMD == "sbatch" ) then
                sbatch -W -o $acqlog $fname
             else
                qsub -W block=true -o $acqlog $fname
             endif
             sleep 2
             set bnymd=`tick $bnymd`
        end

        # Now do an acquire for tomorrows data
        #-------------------------------------
        if ( ( $nlook ) &&  ( ! -e "${FVWORK}/acquire.FAILED" ) ) then
             set la_dtg=`tick $enymd 86400`

             set fname = "acqobs2.pbs"
             set acqdate = ${la_dtg[1]}_`echo $la_dtg[2] | cut -c1-2`z
             set acqlog = $FVHOME/run/acqobs2.log.$acqdate.txt

             fname1 "#\!/bin/csh -xvf"
             fname2 "#$group_list"
             fname2 "#SBATCH --job-name=acqobs2"
             fname2 "#SBATCH --output=acqobs2.log.$acqdate.txt"
             fname2 "#SBATCH --ntasks=1"
             fname2 "#SBATCH --time=2:00:00"
             fname2 "#SBATCH --partition=$data_queue"
             fname2 "#SBATCH --account=$GID"
             fname2 "#PBS -N acqobs2"
             fname2 "#PBS -o acqobs2.log.$acqdate.txt"
             fname2 "#PBS -l nodes=1:ppn=1"
             fname2 "#PBS -l walltime=2:00:00"
             fname2 "#PBS -q $data_queue"
             fname2 "#PBS -S /bin/csh"
             fname2 "#PBS -j eo"
             fname2 ""
             fname2 "setenv DO_DMGET $DO_DMGET"
             fname2 "set path = ( $path )"
             fname2 "cd $FVWORK"
             fname2 "acquire -v -rc obsys.acq -d $spool -s $spool -ssh $la_dtg[1] $la_dtg[2] $inhms $nstep"
             fname2 "exit"

             $BATCH_SUBCMD -o $acqlog $fname
             set acq_status = $status
        endif # if nlook

     endif # test for borg*

  else if ( ($?obsclass ) || ($?req_obsclass ) && ( ! $ecode) ) then

     # Acquire data for obsys on cmd line
     # ----------------------------------
     if ( (`uname -n` !~ borg*) || ( $LOCAL_ACQUIRE ) ) then

        # acquire tcvitals; ignore status return
        #---------------------------------------
        #acquire_obsys -v -d $FVWORK -s $spool -la $nlook -ssh  \
        #              $strict $nymd1 $nhms1 $onhms $nstep ncep_tcvitals

        acquire_obsys -v -d $FVWORK -s $spool -la $nlook -ssh  \
                      $strict $bnymd $bnhms $onhms $nstep $obsclass
        set acq_status = $status  

        if ( ($?req_obsclass ) ) then
           acquire_obsys -v -d $FVWORK -s $spool -la $nlook -ssh  \
                      -strict $bnymd $bnhms $onhms $nstep $req_obsclass
           set acq_status2 = $status  
        endif

     else

        # Do something special when on NCCS linux cluster
        #------------------------------------------------
        set qsub_acquire = 1

        if (`uname -n` =~ borg*) then
           set data_queue=datamove
        else if (`uname -n` =~ r*i[0-3]n*) then
           set data_queue=normal
        else
           set data_queue=""
        endif

        if ( $nstep > 4 ) set nstep = 4
        set anymd = `echo $bnymd | cut -c 3-8`

        while ( ($bnymd <= $enymd[1]) && (! -e "${FVWORK}/acquire.FAILED") && (! -e "${FVWORK}/dmf.FAILED") )
             set look_ahead = 0
             Call SubmitAcquireObsJobs_( $look_ahead )
        end

        # Now do an acquire for tomorrows data but don't wait 
        #----------------------------------------------------
        if ( ( $nlook ) &&  ( ! -e "${FVWORK}/acquire.FAILED" ) ) then
             set la_dtg=`tick $enymd `
             @ esecs = $nlook * $nsecs
             set enymd=`tick $la_dtg $esecs`

             set bnymd = $la_dtg[1]
             set anymd = `echo $bnymd | cut -c 3-8`

             if ( $nlook > 1 ) then
                while ( $bnymd < $enymd[1] )
                     set look_ahead = 1
                     Call SubmitAcquireObsJobs_( $look_ahead )
                end
             endif

       endif # if nlook

     endif # test for borg*

     if ( $CHECK_DMF ) then
         if ( `uname -n` !~ borg* ) then
              set dmf_alive = `cat /archive/input/dao_ops/.DMF_IS_ALIVE`
         else
              set dmf_alive = ""
         endif 
         if ( ( ( `uname -n` !~ borg* ) && ("$dmf_alive" != "DMF_IS_ALIVE" ) ) \
                 || ( -e "${FVWORK}/dmf.FAILED" ) ) then
            set ecode = "93"
            set emessage = "FATAL ERROR: DMF appears to be down.  Stopping."
            echo $myname": $emessage"
         endif
     endif
          
  else

      set acq_status = 0  # nothing to do
      set acq_status2 = 0  # nothing to do

  endif

# Check acq_status
# ----------------
  if ( ( ( -e "${FVWORK}/acquire.FAILED" ) || ( $acq_status ) || ( $acq_status2 ) ) && ( ! $ecode ) ) then
     echo $myname": cannot acquire observational data"
     set ecode = "99"
     set emessage = "FATAL ERROR: $myname cannot acquire observational data"
     echo "$emessage"
  endif 

# Log error message if needed
# ---------------------------
  if ( $log && $ecode ) then
     Err_Log.pl -N ${EXPID}.job.${bnymd} -C $ecode \
        -I $ERROR_ID -X $ERROR_EXP -E 5 $ERROR_LOG_NAME \
        -D "${EXPID}.job.${bnymd} $emessage"
        
  endif
  if ( $ecode ) exit $ecode

                              # Last line of AcquireObservations_()
\end

#.............................................................................

# -----------------------------------------------
  Sub SubmitAcquireObsJobs_( LOOK_AHEAD_FLAG_ )
# -----------------------------------------------
  if ( $?ECHO___ ) set echo

  if ( $LOOK_AHEAD_FLAG_ ) then
        set obsflag = 2
        set acqflags  = "-d $spool -s $spool -e 999"
        set acqflags1 = "$acqflags"
        set blockflag = ""
  else
        if ( !($?strict) )  set strict = ""  
        set obsflag = 1
        set acqflags  = "-d $FVWORK -s $spool -strict"
        set acqflags1 = "-d $FVWORK -s $spool $strict"
        if ( $BATCH_SUBCMD == "sbatch" ) then
           set blockflag = "-W"
        else
           set blockflag = "-W block=true"
        endif
  endif

  # Check for available AOD obs classes
  # -----------------------------------
  if (! $?AERO_OBSDBRC) setenv AERO_OBSDBRC obsys-gaas.rc
  @ numhrs = $nstep * 6
  set rcflag = "-rc $AERO_OBSDBRC"
  set acqname = acqobs$obsflag
  set fname = $acqname.pbs
  set acqdate = ${bnymd}_`echo $bnhms | cut -c1-2`z
  set acqlog = $FVHOME/run/$acqname.log.$acqdate.txt

  if ($obsflag == 1) then
      touch ${FVWORK}/acquire.FAILED
  endif
  fname1 \#\!/bin/csh -xvf
  fname2 \#$group_list
  fname2 \#SBATCH --job-name=$acqname
  fname2 \#SBATCH --output=$acqname.log.$acqdate.txt
  fname2 \#SBATCH --ntasks=1
  fname2 \#SBATCH --time=2:00:00
  fname2 \#SBATCH --partition=$data_queue
  fname2 \#SBATCH --account=$GID
  fname2 \#PBS -N $acqname
  fname2 \#PBS -o $acqname.log.$acqdate.txt
  fname2 \#PBS -l nodes=1:ppn=1
  fname2 \#PBS -l walltime=2:00:00
  fname2 \#PBS -q $data_queue
  fname2 \#PBS -S /bin/csh
  fname2 \#PBS -j eo
  fname2 ""
  fname2 setenv CHECK_DMF  $CHECK_DMF
  fname2 setenv FVWORK $FVWORK
  fname2 setenv IGNORE_0  $IGNORE_0
  fname2 setenv DO_DMGET $DO_DMGET
  fname2 setenv ERROR_LOG_NAME \"$ERROR_LOG_NAME\"
  fname2 setenv EXPID $EXPID
  fname2 @ acqcnt = 0
  fname2 @ acqstatus = 0
  fname2 set path = \( $path \)
  fname2 cd \$FVWORK

  if ( $?req_obsclass ) then
     fname2 acquire_obsys -v $acqflags -ssh  \\
     fname2 "   "$bnymd $bnhms $onhms $nstep ${req_obsclass}
     fname2 @ acqstatus = \$acqstatus + \$status
     fname2 @ acqcnt ++
  endif

  if ( $AOD_OBSCLASS =~ [Nn][Oo][Nn][Ee] ) setenv AOD_OBSCLASS none
  if ( $AOD_OBSCLASS == "" )               setenv AOD_OBSCLASS none
  if ( $AOD_OBSCLASS == 0 )                setenv AOD_OBSCLASS none

  if ($GAAS_ANA && $aerosol_acquire && ("$AOD_OBSCLASS" != "none")) then
      @ mstep = $nstep * 2
      fname2 acquire_obsys -v $acqflags -ssh -drc $AERO_OBSDBRC \\
      fname2 "      "$bnymd $bnhms 030000 $mstep \\
      fname2 "      "$AOD_OBSCLASS
      fname2 @ acqstatus = \$acqstatus + \$status
      fname2 @ acqcnt ++
      if ($obsflag == 1) then
          fname2 setup_gaas_obs.pl \$FVWORK -v -avhrr -modis
      endif
  endif
  if ( $?obsclass ) then
     fname2 acquire_obsys -v $acqflags1 -ssh  \\
     fname2 "      "$bnymd $bnhms $onhms $nstep $obsclass
     fname2 @ acqstatus = \$acqstatus + \$status
     fname2 @ acqcnt ++
  endif

  if ($obsflag == 1) then
     fname2 if \( ! \$acqcnt \|\| ! \$acqstatus \) then
     fname2 "    "/bin/rm -f \$FVWORK/acquire.FAILED
     fname2 endif
     fname2 if \( \$acqcnt \) then
     fname2 "    "set dmf_alive = \`cat /archive/input/dao_ops/.DMF_IS_ALIVE\`
     fname2 "    "if \( .\$dmf_alive != .DMF_IS_ALIVE \&\& \$CHECK_DMF \) then
     fname2 "         "touch \$FVWORK/dmf.FAILED
     fname2 "    "endif
     fname2 endif
  endif

  # submit job script
  #------------------
  $BATCH_SUBCMD $blockflag -o $acqlog $fname  # acquire observations; ignore status return
  sleep 2
  if ($obsflag == 1 && ( -e obsys.acq )) then
     cat obsys.acq >>! obsys.acq.all
  endif

  # increment date
  #---------------
  set bnymd=`tick $bnymd`
  set anymd = `echo $bnymd | cut -c 3-8`

                              # Last line of SubmitAcquireObsJobs_
\end

#.............................................................................

# -------------------------
  Sub PreAnalysisQC_()
# -------------------------
  if ( $?ECHO___ ) set echo

# Get info about pre-qc files to be combined for QC
# ------------------------------------------------------
 
# Check for special handling on discover  
 if ( ( $qsub_acquire && ( -e obsys.acq.all ) ) || ( -e obsys.acq ) ) then
       if ( -e obsys.acq.all ) then
            set acq = "obsys.acq.all"
       else
            set acq = "obsys.acq"
       endif

# Copy acquire rc file to run directory
       /bin/cp $acq  ${FVHOME}/run/obsys.acq.latest

# Check for pre-qc in files from OBSCLASS
       set aacq = "obsclass_pre-qc.rc"
       extract_pre-qc.pl obsys.rc $aacq

   if ( `grep -c pre-qc $aacq` ) then
# Remove hard-wired times
       grep pre-qc $aacq | grep -v ^\# | grep "%h2" | cut -d\> -f2 > pre-qc_acq 
       grep pre-qc $aacq | grep -v ^\# | grep -v "%h2" | sed 's/\.t..z\./.t%h2z./' | cut -d\> -f2 >> pre-qc_acq 

# Remove duplicate entries
       cat pre-qc_acq | sort | uniq > pre-qc.acq

# Check for pre-existing prepbufr file
       ls *.prepbufr.*

# Prepare obsys file for lnlist processing
       if ( $status && ! -z pre-qc.acq && -e pre-qc.acq ) then
            /bin/mv $acq obsys.acq.orig
            grep -v pre-qc obsys.acq.orig | grep -v ^\# | sort | uniq > obsys_acq
            echo "/this/is/a/dummy/path =>  $EXPID.prepbufr.%y4%m2%d2.t%h2z.blk" >>! obsys_acq
            /bin/mv ${FVHOME}/run/obsys.acq.latest ${FVHOME}/run/obsys.acq.raw
            /bin/cp obsys_acq  ${FVHOME}/run/obsys.acq.latest
       endif
  else
        cat $acq | grep -v ^\# | sort | uniq > obsys_acq
  endif
endif 

# Fix unblocked files
# -------------------
  zeit_ci.x FixUnblocked
  foreach ublk ( `ls *.ublk` )
      FixUnblocked.csh $ublk &
  end
  wait
  ls *FAILED_BLOCK
# if ( ( ! $status ) && ( $STRICT ) ) exit 96 
  if ( ! $status ) exit 96 
  zeit_co.x FixUnblocked

# Flip QM=9 flag for ASCAT in prepbufr
# ------------------------------------
  if ( $USE_ASCAT ) then
     echo "Will flip ASCAT flag in prepbufr."
     foreach prepbf ( `ls *prepbuf*.ublk` )
        fix_ascat.x $prepbf ${prepbf}_ascat
        /bin/ls -l $prepbf ${prepbf}_ascat
        /bin/mv ${prepbf}_ascat $prepbf
     end
  endif

# Fix big_endian/little_endian in the upa-buffer files
# ----------------------------------------------------
  zeit_ci.x FixEndian
  if ( ( `uname -s` == "OSF1" ) || (`uname -s` == "Linux" && (`uname -m` == "ia64" || `uname -m` == "x86_64")) ) then  
     foreach upa ( `ls *upabufr*bfr` )
         Reblock.csh $upa &
     end
     foreach blk ( `ls *.blk` )
          Reblock.csh $blk &
     end
  endif
  wait 
  ls *FAILED_BLOCK
# if ( ( ! $status ) && ( $STRICT ) ) exit 96 
  if ( ! $status ) exit 96 
  zeit_co.x FixEndian

                              # Last line of PreAnalysisQC_()
\end


#.............................................................................

# --------------------------------
  Sub QualityControlRun_()
# --------------------------------
  if ( $?ECHO___ ) set echo

   if ( ! $PREPQC ) exit 0
   if (  $SKIPANA ) exit 0

# Combine pre-qc files...
#  ------------------------
   set opt_pb = ""
   set pbname = `echorc.x -template $EXPID $nymdb $nhmsb -fill %s.prepbufr.%y4%m2%d2.t%h2z.blk`
   set pbdtg  = `token_resolve %y4%m2%d2%h2 $nymdb $nhmsb`
   if (-e pre-qc.acq && ! -e prepqc.daemon.running) then
      if ( ! -z pre-qc.acq ) then
         /bin/rm -f input_combfr.txt
         touch input_combfr.txt
         foreach qcpat ( `cat pre-qc.acq | sort | uniq`)
            echorc.x -template dummy $nymdb $nhmsb -fill $qcpat >> input_combfr.txt
         end
         combfrd.x -d $pbdtg $pbname < input_combfr.txt
         scanbuf0.x  $pbname >! data_types.log

         if ( `grep PROFLR data_types.log | wc -l `) then
           setenv PROFQC 1
         else
           setenv PROFQC 0
         endif

         if ( `grep AIRCFT data_types.log | wc -l`) then
           setenv ACFTQC 1
         else
           setenv ACFTQC 0
         endif

         if  ( `grep AIRCAR data_types.log | wc -l`) then
           setenv ACARSQC 1
         else
           setenv ACARSQC 0
         endif
      endif
   endif
   ls -l $pbname
   if ( -e $pbname && (! -z $pbname) ) then
         set opt_pb = "-pb $pbname"
   else
         if( -z $pbname ) /bin/rm $pbname
         set opt_pb = ""
   endif

   set bkgfile  = `echorc.x -template $EXPID $nymdb $nhmsb upper-air_bkg_filename`
   prepqc.pl $opt_pb $nymdb $nhmsb $bkgfile 
   if ( $status ) then
       Call AbnormalExit_( 2 )
   endif  

   if ( ($HYBRIDGSI != "/dev/null") ) then
     if ( ($STAGE4HYBGSI != "/dev/null") ) then
        if (! -e $FVHOME/run/atmens_replay.acq) then
           /bin/cp $pbname $STAGE4HYBGSI/
        endif
     endif
   endif
                              # Last line of QualityControlRun_()
\end
#.............................................................................

# --------------------------------
  Sub DetermineExecutables_()
# --------------------------------
  if ( $?ECHO___ ) set echo

  if( $SVEC ) set gcmexec = fvsvec.x
  if( $SENS ) set gcmexec = fvsens.x

                              # Last line of DetermineExecutables_
\end


#.............................................................................

# ------------------------------
  Sub SplitExecInit_()
# ------------------------------
  if ( $?ECHO___ ) set echo

      echo " Running DAS in Split Executable Mode "

      setenv DOETA2BIN 1
      @ afreqsc =   $afreqhr * 3600              # analysis freq in seconds
      @ nhmse_osec = ( $nhmse / 10000 ) * 3600   # original end-time in seconds
      if ( $?NSEGS ) then
            @ nsegs = $NSEGS
      else
            @ nsegs = 240000 / $nhmsa
      endif  

                              # Last line of SplitExecInit_ 
\end


#.............................................................................

# --------------------------------
  Sub SplitExecSegmentTimes_()
# --------------------------------
  if ( $?ECHO___ ) set echo

#    Extract current date from restart and set end of this segment
#    -------------------------------------------------------------
         set stdate  = `rst_date d_rst`
         set gcm_nymd0   = $stdate[1]   # begin date of forecast
         set gcm_nhms0   = $stdate[2]   # begin time of forecast
         set gcm_nhr0 = `echo $gcm_nhms0 | cut -c1-2`   # begin hour of forecast
         if ( $VAROFFSET ) then
            set this_seg_end = `tick ${stdate} ${afreqsc}`
            set gcm_nymdb    = $this_seg_end[1]          # gcm initial date for next cycle
            set gcm_nhmsb    = $this_seg_end[2]          # gcm initial time for next cycle
            set stdate       = `tick ${gcm_nymd0} ${gcm_nhms0} $aoffset_sec`
            set nymdb        = $stdate[1]                # first synoptic date within var window
            set nhmsb        = $stdate[2]                # first synoptic time within var window
            set this_seg_end = `tick ${stdate} ${afreqsc}`
            set ana_nymde    = $this_seg_end[1]          # next analysis date
            set ana_nhmse    = $this_seg_end[2]          # next analysis time
         else         
            set nymdb        = $gcm_nymd0                # gcm initial date for next cycle
            set nhmsb        = $gcm_nhms0                # gcm initial time for next cycle
            set this_seg_end = `tick ${stdate} ${afreqsc}`
            set ana_nymde    = $this_seg_end[1]
            set ana_nhmse    = $this_seg_end[2]
            set gcm_nymdb    = $ana_nymde
            set gcm_nhmsb    = $ana_nhmse
         endif
         @ thishrs        = ${nhmsb} / 10000
         set fcsthrb      = `echo $thishrs |awk '{printf "%02d", $1}'` # two-digit hour this seg ends
         @ thishrs        = ${gcm_nhmsb} / 10000
         set fcsthre      = `echo $thishrs |awk '{printf "%02d", $1}'` # two-digit hour this seg ends

#        Set timers for asynoptic issue of background (9-hr forecasts)
#        -------------------------------------------------------------
         if ( $ASYNBKG ) then
              @ asynoset_sec = $ASYNBKG * 60
              @ asynoset_hrs = $ASYNBKG / 60
         else
              set fcst_nymde    = $nymdb
              set fcst_nhmse    = $nhmsb
         endif

#        When doing replay we will need this info based on
#         the current time values
#        --------------------------------------------------
         set sfcfile  = `echorc.x -template $EXPID $nymdb $nhmsb surface_bkg_filename`
         set bkgfile  = `echorc.x -template $EXPID $nymdb $nhmsb upper-air_bkg_filename`
         set anafile  = `echorc.x -template $EXPID $nymdb $nhmsb upper-air_ana_filename`

                              # Last line of 
\end

#.............................................................................

# ----------------------------------
  Sub AnalysisRun_( Viter_, Final_ ) 
# ----------------------------------
  if ( $?ECHO___ ) set echo

    if ( $DO4DVAR && $Final_ ) exit 0

#_RT      if ( -e $FVHOME/run/.anadone.$nymdb.$nhmsb ) /bin/rm $FVHOME/run/.anadone.$nymdb.$nhmsb  # analysis is being redone
#          Checkpoint AnalysisRun: exit when already done
#          ----------------------------------------------
           set hhb = `echo $nhmsb | cut -c1-2`
           if (-e $FVWORK/.DONE_MEM001_AnalysisRun.${nymdb}${hhb} ) exit 0


#          Get dimension of analysis (this defines berror dim)
#          ---------------------------------------------------
           set gsinlat = `echorc.x -rc GSI_GridComp.rc "GSI JM"` 
           set gsinlon = `echorc.x -rc GSI_GridComp.rc "GSI IM"` 
           set gsinlev = `echorc.x -rc GSI_GridComp.rc "GSI LM"` 
           if( $DO4DVAR ) then
             @ jiter = $Viter_ + 1
             if ( -e gsi_fdda_$jiter.rc.tmpl ) then
                 /bin/mkdir -p trajdir_$Viter_
                 /bin/mv *traj.lcv*.$NCSUFFIX trajdir_$Viter_
#                /bin/mv *ptrj.prs*.$NCSUFFIX trajdir_$Viter_
                 # fix absence initial trajectory
                 cd trajdir_$Viter_
                 set lsttraj = `ls -1 *traj.lcv.*$NCSUFFIX`
                 set prefix_traj0 = `echo $lsttraj[1] | cut -d. -f1-3`
                 set   nymd_traj0 = `echo $lsttraj[1] | cut -d. -f4 | cut -c1-8`
                 set     hh_traj0 = `echo $lsttraj[1] | cut -d. -f4 | cut -c10-11`
                 /bin/cp $lsttraj[1] $prefix_traj0.${nymd_traj0}_${hh_traj0}00z.$NCSUFFIX
                 reset_time.x $prefix_traj0.${nymd_traj0}_${hh_traj0}00z.$NCSUFFIX ${nymd_traj0} ${hh_traj0}0000 -9
                 cd -
             endif
           endif

#          Run Analysis
#          ------------
           set sfcfile  = `echorc.x -template $EXPID $nymdb $nhmsb surface_bkg_filename`
           set bkgfile  = `echorc.x -template $EXPID $nymdb $nhmsb upper-air_bkg_filename`
           set anafile  = `echorc.x -template $EXPID $nymdb $nhmsb upper-air_ana_filename`
           set odsfile  = `echorc.x -template $EXPID $nymdb $nhmsb post-analysis_obs_filename`
           set biasfile = `echorc.x -template $EXPID $nymdb $nhmsb forecast-bias_filename`
           if ( $SKIPANA ) then
              /bin/cp $bkgfile $anafile
           else

#             Check tcvitals for valid entries
#             (assumes tcvitals.yyyymmddhh naming convention)
#             ------------------------------------------------
              foreach vitals  ( `ls *tcvitals*` )
                      echo "Checking $vitals for valid entries."
                      cat $vitals
                      set tcvdate = `echo $vitals | cut -d . -f2 | cut -c 1-8`
                      set tcvtime = `echo $vitals | cut -d . -f2 | cut -c 9-10`00
                      \rm -f ${vitals}.tmp
                      mv $vitals ${vitals}.tmp
                      cat ${vitals}.tmp | grep "$tcvdate $tcvtime" > $vitals
                      echo "Corrected ${vitals}:"
                      cat  $vitals
                      \rm -f ${vitals}.tmp
              end

#             then run analysis
#             -----------------
              $dryrun analyzer $nymdb $nhmsb -expid $EXPID -t $SPECRES -levs $gsinlev -x $gsinlon -y $gsinlat -jiter $Viter_ $lnobs -log ana.log
              if ( ${status} ) then
                  Call AbnormalExit_( 3 )
              endif

              set ana_check = ( `grep ">>> WARNING <<< does not exist" ana.log | cut -d '<' -f4` )
              if ( ( $#ana_check ) && ( $log ) ) then
                   echo $myname"$ana_check"
                   Err_Log.pl -N ${EXPID}.j -I $ERROR_ID -X $ERROR_EXP -C 99 \
                           -E 1 $ERROR_LOG_NAME \
                           -D "${EXPID}.j WARNING: analyzer: $ana_check"
              endif

              if ( $ANGLEBC && $DIAGTAR ) then
                 ls -l radstat
                 $dryrun make_diagtarfile.csh $EXPID $nymdb $nhmsb radstat
                 ls -l radstat
              endif


#             When all is well, drop an egg in the run directory to indicate this analysis is done
#             ------------------------------------------------------------------------------------
#_RT          if (! -e $FVHOME/run/.anadone.$nymdb.$nhmsb ) touch $FVHOME/run/.anadone.$nymdb.$nhmsb  # means analysis is done

           endif

#          Handle aod analysis files when doing ensemble ADAS
#          --------------------------------------------------
           if ( $GAAS_ANA && ($HYBRIDGSI != "/dev/null") ) then
              if (! -e $FVHOME/run/atmens_replay.acq) then
                 set notfound = 1
                 foreach aod_type ( aod_a.sfc aod_d.sfc aod_f.sfc aod_k.sfc )
                    /bin/cp *.${aod_type}.*.$NCSUFFIX $STAGE4HYBGSI/
                    if (! $status) then
                       set notfound = 0
                    endif
                 end
                 if ( $notfound && ( ! -e $FVHOME/run/gaas/GAAS.BOOTSTRAP ) ) then
                    echo "Cannot find AOD Analysis and related files. Aborting ..." 
                    Call AbnormalExit_( 1 )
                 endif
              endif
           endif

#          Signal successful completion
#          ----------------------------
           if ( $Final_ ) then
              touch $FVWORK/.DONE_MEM001_AnalysisRun.${nymdb}${hhb}
           endif

#
                              # Last line of AnalysisRun_()  
\end

#.............................................................................

# ----------------------------------
  Sub JEDI_AnalysisRun_( Viter_, Final_ ) 
# ----------------------------------
  if ( $?ECHO___ ) set echo
#

  if ( ! -d $FVHOME/run/jedi )  exit (0)

  @ idummy = $VAROFFSET * 60
  set ana_datetime = ( `tick $gcm_nymd0 $gcm_nhms0 $idummy` )

  set this_hh0 = `echo $gcm_nhms0 | cut -c1-2`

  jedi_driver.csh $gcm_nymd0 $gcm_nhms0 $ana_datetime[1] $ana_datetime[2] |& tee -a $FVWORK/$EXPID.jedi_drv.log.${gcm_nymd0}_${this_hh0}z.txt
  if ( $status ) then
     echo "JEDI analysis failed, aborting ..."
     Call AbnormalExit_( 1 )
  endif

                              # Last line of JEDI_AnalysisRun_()  
\end

#.............................................................................

# ------------------------------
  Sub StageAna4FSens_() 
# ------------------------------
  if ( $?ECHO___ ) set echo

     if( ! -e stage4fsens.arc ) exit 0  # if so, submit job for forecast sensitivity
     if( ! $doFSENS ) exit 0

     # -------------------------------------------
     @ pesto_status = 0
     if ( ($?STAGE4FSENS) ) then
         setenv PESTOROOT $STAGE4FSENS/s4fsens.$nymdb.$nhmsb

         # Stage on analysis
         # -----------------
         set afiletmpl = `grep ana.eta stage4fsens.arc`
         set afile = `echorc.x -template $EXPID $nymdb $nhmsb -fill $afiletmpl`
         if (-e xxxana.arc) /bin/rm xxxana.arc
         echo $afile > xxxana.arc

         # Move analysis file to forecast staging area
         # -------------------------------------------
         pesto -v -d $FVWORK -arc xxxana.arc
         @ pesto_status = $status
     else
         echo " Env Var STAGE4FSENS not defined"
         @ pesto_status = 1
     endif

     # Halt if pesto fails
     # -------------------
     if ( $pesto_status ) then
         echo " Trouble in StageAna4FSens_: pesto failed"
         exit 1
     endif

  #--endif

                              # Last line of StageAna4FSens_()  
\end

#.............................................................................


# ------------------------------
  Sub EvolveAinc0_( Viter_, Final_ )
# ------------------------------
  if ( $?ECHO___ ) set echo

  if ( ! $DO4DTLM ) exit 0
  if ( ! $DO4DVAR ) exit 0
  if ( ! $DO4DIAU ) exit 0

  if ( $Final_ ) exit 0

  # for now, only do it once ...
  @ viterp1 = $Viter_ + 1
  echo "EvolveAinc0_, iteration: $viterp1 "
# if ( $viterp1 > 1 ) exit 0 

# Run TLM over this period of time
# set runtlm_mn = $ASYNBKG  # if set to this, runs TLM in chucks of times based on BKG freq (WC form)
  set runtlm_mn = $TIMEINC  # if set to this, runs TLM in single shot over time of assim window (SC form)
  @ runtlm_sc = $runtlm_mn * 60

  if ( ! -d $FVHOME/run/fwdpert ) then
     echo "Cannot find resources directory to run TLM"
     Call AbnormalExit_( 2 )
  endif

# Loop over analysis period (excluding the last time-slot)
# --------------------------------------------------------
  set this_next = ( $beg_ana )
  while ( $this_next[1] != $end_ana[1] || $this_next[2] != $end_ana[2] )

     set xincfn = `echorc.x -template $EXPID $this_next[1] $this_next[2] upper-air_xinc_filename`
     if ( ! -e $xincfn ) then
        echo "Cannot find initial time analysis increment"
        Call AbnormalExit_( 1 )
     endif

     fvpert $FVWORK $FVHOME/run/fwdpert $EXPID $this_next[1] $this_next[2] $runtlm_mn \
            $xincfn

     set this_next  = ( `tick $this_next[1] $this_next[2] $runtlm_sc` )

  end # <while>

# If so, save all original increments and overwrite them with evolved pert
# ------------------------------------------------------------------------
  set overwrite = "NO"
  if ( -e $FVHOME/run/fwdpert/updAincWpert.rc.tmpl ) then
      set overwrite = `echorc.x -rc $FVHOME/run/fwdpert/updAincWpert.rc.tmpl OVERWRITE_ANAINC`
  endif
  @ bkgfrq_sc = $ASYNBKG * 60
  set this_next = ( $beg_ana )
  set aincfn = `echorc.x -template $EXPID $this_next[1] $this_next[2] upper-air_inc_filename`
  set xincfn = `echorc.x -template $EXPID $this_next[1] $this_next[2] upper-air_xinc_filename`
  set pertfn = `echorc.x -rc $FVHOME/run/fwdpert/updAincWpert.rc.tmpl -template $EXPID $this_next[1] $this_next[2] PERT_FILENAME`
  /bin/cp $xincfn $pertfn  # initial time does not change
  if ( "$overwrite" == "YES" || "$overwrite" == "yes" ) then
     /bin/cp $xincfn $aincfn
     while ( $this_next[1] != $end_ana[1] || $this_next[2] != $end_ana[2] )
         set this_next  = ( `tick $this_next[1] $this_next[2] $bkgfrq_sc` )
         set aincfn = `echorc.x -template $EXPID $this_next[1] $this_next[2] upper-air_inc_filename`
         set xincfn = `echorc.x -template $EXPID $this_next[1] $this_next[2] upper-air_xinc_filename`
         set pertfn = `echorc.x -rc $FVHOME/run/fwdpert/updAincWpert.rc.tmpl -template $EXPID $this_next[1] $this_next[2] PERT_FILENAME`
         /bin/cp $xincfn $aincfn
         /bin/cp $pertfn $xincfn
     end # <while>
     # finally add iteration number identifier to relevant filenames
     # NOTE: cannot retag xinc.eta here ... this happens later 
     foreach fntyp ( inc.eta )
        rndasfiles -purge $EXPID $fntyp $beg_ana[1] $beg_ana[2] \
                                        $end_ana[1] $end_ana[2] $ASYNBKG $viterp1
     end
  endif
  foreach fntyp ( fvpert.eta )
     rndasfiles -purge $EXPID $fntyp $beg_ana[1] $beg_ana[2] \
                                     $end_ana[1] $end_ana[2] $ASYNBKG $viterp1
  end

# Signal successful completion
# ----------------------------
  set this_hh = `echo $beg_ana[2] | cut -c1-2`
  touch $FVWORK/.DONE_MEM001_EvolveAinc0_${viterp1}.${beg_ana[1]}${this_hh}


                              # Last line of EvolveAinc0_()

\end

#.............................................................................

# ------------------------------
  Sub CoupleAnaToGcm_( Viter_, Final_ )
# ------------------------------
  if ( $?ECHO___ ) set echo

        set updrst0 =
        if ( "$MPIRUN_UPRST" != "/dev/null" ) then
           set updrst0 = "-updrst0"
        endif
#       Move previous IAU tendency files out of the way
        if ( $DO4DVAR || $DO4DIAU ) then
             if ( $Viter_ > 0 ) then
                @ viterm1 = $Viter_ - 1
                set fn = "agcm_import_rst"
                rndasfiles -sfx "bin" -purge $EXPID $fn $beg_ana[1] $beg_ana[2] \
                                                        $end_ana[1] $end_ana[2] $ASYNBKG $Viter_
             endif
         endif

         @ adtfwd = $varwindow_sec
         set beg_ana = ( $gcm_nymd0 $gcm_nhms0 )
         set end_ana = ( `tick $beg_ana[1] $beg_ana[2] $adtfwd` )

         if ( $DO4DVAR && $Final_ ) exit 0

#        Checkpoint CoupleAnaToGcm: skip when already completed
         set ddz = $beg_ana[1]
         set hhz = `echo $beg_ana[2] | cut -c1-2`
         if ( -e $FVWORK/.DONE_MEM001_CoupleAnaToGcm_${Viter_}.${ddz}${hhz} ) exit 0

         @ viterp1 = $Viter_ + 1

         if ( $DOETA2BIN ) then

#          Link to GEOS-5 GCM boundary condition files
#          -------------------------------------------
           lnbcs $nymdb || exit 95 


#          GEOS-5 GCM, need to convert ana "eta" files into rst (and overwrite existing rsts for fvcore and moist)
#          -------------------------------------------------------

              if ( $DOIAU ) then

                  if ( $DO4DIAU ) then  # Perform 4D-analysis update (from GSI increments) &
                                        # generate 4D-GCM forcing terms (IAU tendencies)

#_RT                 if ( -e $anafile ) then
#_RT                    # get original analysis out of the way (it will be re-created)
#_RT                    /bin/mv $anafile $anafile.orig
#_RT                 endif

                     if ( "$updrst0" == "-updrst0" ) then
                        foreach fn ( fvcore_internal_rst moist_internal_rst pchem_internal_rst )
                            if ( $Viter_ == 0 ) then
                               /bin/mv $fn ${fn}_iter0
                               ln -sf ${fn}_iter0 $fn
                            endif
                        end
                     endif

                     ana4dupd.pl -ncpus 7 -iau -iter $Viter_ -rcdir . $updrst0 \
                                            $EXPID $beg_ana[1] $beg_ana[2] \
                                                   $end_ana[1] $end_ana[2] $ASYNBKG
                     set my_status = $status

                     # When updating initial condition ...
                     if ( "$updrst0" == "-updrst0" && ! $Final_ ) then
                        foreach fn ( fvcore_internal_rst moist_internal_rst pchem_internal_rst )
                                set thishh = `echo $beg_ana[2] | cut -c1-2`
                                rndasfiles -sfx $RSTSUFFIX -purge $EXPID $fn $beg_ana[1] $beg_ana[2] \
                                                                             $beg_ana[1] $beg_ana[2] 0 $viterp1
                                /bin/rm $fn
                                ln -sf $EXPID.$fn.$beg_ana[1]_${thishh}z.iter$viterp1.bin $fn
                        end
                     endif

                     set agcmfn = `echorc.x -template $EXPID $beg_ana[1] $beg_ana[2] iau_tendency_filename`
                     /bin/ln -sf $agcmfn agcm_import_rst

                     if ( ($HYBRIDGSI != "/dev/null") && (! -e $FVHOME/run/atmens_replay.acq) ) then
                        if ( $Final_ && ($STAGE4HYBGSI != "/dev/null") ) then
                             rndasfiles -stage $STAGE4HYBGSI $EXPID ana.eta $beg_ana[1] $beg_ana[2] \
                                                                            $end_ana[1] $end_ana[2] $ASYNBKG 99

                             touch $FVHOME/.DONE_MEM001_analyzer.${nymdb}${hhb}
                        endif
                     endif

                     # save ana/xinc files at end time-slot before these are overwritten by cycle
                     set ana09upa  = `echorc.x -template $EXPID $end_ana[1] $end_ana[2] upper-air_ana09_filename`
                     set ana_upa   = `echorc.x -template $EXPID $end_ana[1] $end_ana[2] upper-air_ana_filename`
                     /bin/cp $ana_upa $ana09upa

                     set xinc09upa  = `echorc.x -template $EXPID $end_ana[1] $end_ana[2] upper-air_xinc09_filename`
                     set xinc_upa   = `echorc.x -template $EXPID $end_ana[1] $end_ana[2] upper-air_xinc_filename`
                     /bin/cp $xinc_upa $xinc09upa

                     set iau09inc  = `echorc.x -template $EXPID $end_ana[1] $end_ana[2] iau09_tendency_filename`
                     set iau_inc   = `echorc.x -template $EXPID $end_ana[1] $end_ana[2] iau_tendency_filename`
                     /bin/cp $iau_inc $iau09inc

                  else  # Regular (3D) IAU

                     set bkg06upa  = `echorc.x -template $EXPID $nymdb $nhmsb upper-air_bkg06_filename`
                     set ifile     = `echorc.x -template $EXPID $nymdb $nhmsb upper-air_inc_filename`
                     if ( -e $bkg06upa ) then
                          set bkg4iau = $bkg06upa
                     else
                          set bkg4iau = $bkgfile
                     endif
                    
                     if ( -e mkiau.rc.tmpl ) then
                  
                         if ( -e replay.acq && -e replay_agcm.acq ) then
                            touch IAU_EGRESS
                            set myiau_full = `echorc.x -template $EXPID $gcm_nymd0 $gcm_nhms0 iau_tendency_filename`
                            set myiau_shrt = `echorc.x -rc mkiau.rc.tmpl -template $EXPID $gcm_nymd0 $gcm_nhms0 AGCM_INTERNAL_CHECKPOINT_FILE`
                            if ( -e $myiau_full ) then
                               /bin/cp $myiau_full $myiau_shrt
                            else
                               echo "Cannot find: $myiau_full"
                               set status = 1
                               if ( ${status} ) then
                                   Call AbnormalExit_( 4 )
                                endif
                            endif
                         else

                            /bin/rm -f sed_file

                            echo "s/>>>EXPID<<</${EXPID}/1"         > sed_file
                            echo "s/>>>BKGFNAME<<</${bkg4iau}/1"   >> sed_file
                            echo "s/>>>ANAFNAME<<</${anafile}/1"   >> sed_file
                            echo "s/>>>NCSUFFIX<<</${NCSUFFIX}/1"  >> sed_file
                            echo "s/>>>ANADATE<<</${nymdb}/1"      >> sed_file
                            echo "s/>>>ANATIME<<</${nhmsb}/1"      >> sed_file
                            /bin/rm -f ./mkiau.rc
                            sed -f sed_file  ./mkiau.rc.tmpl  > ./mkiau.rc
                            $makeiaux

                         endif

                     else

                         set imout = `grep AGCM_IM: AGCM.rc.tmpl | cut -d : -f2`
                         set jmout = `grep AGCM_JM: AGCM.rc.tmpl | cut -d : -f2`
                         $makeiaux -ana $anafile -bkg $bkg4iau \
                                   -imout $imout -jmout $jmout \
                                   -divr -iau agcm_import_rst \
                                   -nymd $nymdb -nhms $nhmsb
  
                     endif
                     if ( -e IAU_EGRESS ) then
                        echo "IAU increment generated"
                        /bin/rm -f IAU_EGRESS  # clean up and move on
                     else
                        echo "Failed to generate IAU increment"
                        set status = 1
                     endif
                     if ( ${status} ) then
                         Call AbnormalExit_( 4 )
                     endif
 
                    set myiau = `echorc.x -template $EXPID $gcm_nymd0 $gcm_nhms0 iau_tendency_filename`
                    /bin/cp -f agcm_import_rst $myiau

                    # create increment file to allow for multiple options of running DAS

                    dyn_recenter.x -g5 $anafile $bkg4iau NONE -o $ifile

                  endif  # 3D/4D IAU

              else  # 4DVAR or FGAT

                 if ( $WCONSTRAINT ) then  # For now, this means FGAT

                    # Update all backgrounds with available increments ...

                    if ( $DO4DIAU ) then

                       if ( "$updrst0" == "-updrst0" ) then
                          foreach fn ( fvcore_internal_rst moist_internal_rst pchem_internal_rst )
                              if ( $viterp1 == 1 ) then
                                 /bin/mv $fn ${fn}_iter0
                                 # in this case, always reset link to very first initial RST files
                                 # before going into ana4upd ...
                                 ln -sf ${fn}_iter0 $fn
                              endif
                          end
                       endif

                       ana4dupd.pl -ncpus 7 -iau -iter $Viter_ -rcdir . $updrst0 \
                                              $EXPID $beg_ana[1] $beg_ana[2] \
                                                     $end_ana[1] $end_ana[2] $ASYNBKG
                       set my_status = $status

                       # When updating initial condition ...
                       if ( "$updrst0" == "-updrst0" ) then
                          foreach fn ( fvcore_internal_rst moist_internal_rst pchem_internal_rst )
                                  set thishh = `echo $beg_ana[2] | cut -c1-2`
                                  rndasfiles -sfx $RSTSUFFIX -purge $EXPID $fn $beg_ana[1] $beg_ana[2] \
                                                                               $beg_ana[1] $beg_ana[2] 0 $viterp1
                                  /bin/rm $fn
                                  ln -sf $EXPID.$fn.$beg_ana[1]_${thishh}z.iter$viterp1.bin $fn
                          end
                       endif

                    else
                       ana4dupd.pl -iau -iter $Viter_ -rcdir . \
                                              $EXPID $wrt_inc[1] $wrt_inc[2] \
                                                     $wrt_inc[1] $wrt_inc[2] 0
                       set my_status = $status

                       set myiau = `echorc.x -template $EXPID $wrt_inc[1] $wrt_inc[2] iau_tendency_filename`
                       if( -e $myiau ) then
                          /bin/cp -f $myiau agcm_import_rst
                       else
                          set my_status = 4
                       endif

                    endif # <DO4DIAU>
                    set status = $my_status
                    if ( $status ) then
                        echo "Failed to generate IAU increment"
                        Call AbnormalExit_( 4 )
                    endif
 
                    # Move all backgrounds/etc to names indicating iteration number
                    # Special-handle bkg at initial time
                     if ( ! -e IDFUPD.rc.tmpl ) then # only when not doing digital filter

#                       Before renaming file check for present of initial-time analysis and store a copy ...
                        set ana0  = `echorc.x -template $EXPID $beg_ana[1] $beg_ana[2] upper-air_ana_filename`
                        set bkg0  = `echorc.x -template $EXPID $beg_ana[1] $beg_ana[2] upper-air_bkg_filename`
                        set tmp0  = bkg.eta.time0.$NCSUFFIX
                        if ( -e $ana0 ) then
                           /bin/cp $ana0 $tmp0
                        endif

                        if ( $DO4DIAU ) then
                           rndasfiles -purge $EXPID  xinc.eta $beg_ana[1] $beg_ana[2] \
                                                              $end_ana[1] $end_ana[2] $ASYNBKG $viterp1
                           rndasfiles -purge $EXPID   ana.eta $beg_ana[1] $beg_ana[2] \
                                                              $end_ana[1] $end_ana[2] $ASYNBKG $viterp1
                        else
                           rndasfiles -purge $EXPID inc.eta $wrt_inc[1] $wrt_inc[2] \
                                                            $wrt_inc[1] $wrt_inc[2] 0 $viterp1
                           rndasfiles -purge $EXPID ana.eta $wrt_inc[1] $wrt_inc[2] \
                                                            $wrt_inc[1] $wrt_inc[2] 0 $viterp1
                        endif

                        if ( -e $FVHOME/run/ut_recenter.csh ) then # just for now ... RTodling
                           ut_recenter.csh $viterp1
                           if ( $status ) then
                               echo "Failed to updating ens B "
                               Call AbnormalExit_( 4 )
                           endif
                        endif

                        rndasfiles $EXPID  bkg.eta $beg_ana[1] $beg_ana[2] \
                                                   $end_ana[1] $end_ana[2] $ASYNBKG $Viter_
                        rndasfiles $EXPID  bkg.sfc $beg_ana[1] $beg_ana[2] \
                                                   $end_ana[1] $end_ana[2] $ASYNBKG $Viter_
                        rndasfiles $EXPID cbkg.eta $beg_ana[1] $beg_ana[2] \
                                                   $end_ana[1] $end_ana[2] $ASYNBKG $Viter_
                        rndasfiles $EXPID abkg.eta $beg_ana[1] $beg_ana[2] \
                                                   $end_ana[1] $end_ana[2] $ASYNBKG $Viter_

#                       When applicable, replace initial-time background with initial-time analysis
                        if ( -e $tmp0 ) then
                           echo "CoupleAnaToGcm_: Overwrite initial-time background with $ana0"
                           /bin/mv $tmp0 $bkg0
                        endif
####  TEST TEST TEST
##                      /bin/cp $FVHOME/recycle/fd515_1rt.ana_satbang_rst.20141203_21z.txt satbang
##                      /bin/cp $FVHOME/recycle/fd515_1rt.ana_satbias_rst.20141203_21z.txt satbias
                     endif

                     # PROBLEMS HERE: 1. the initial bkg is never corrected; all other bkg's are corrected
                     #                   via the forced integration of the GCM.
                     #                2. how do I handle windows longer than 6 hrs?


                 else # < NOT WCONSTRAINT >
                      #                  Update model's initial condition
                      #                  --------------------------------

                     set sfile  = `echorc.x -template $EXPID $wrt_ana[1] $wrt_ana[2] surface_bkg_filename`
                     set afile  = `echorc.x -template $EXPID $wrt_ana[1] $wrt_ana[2] upper-air_ana_filename`
                     set bfile  = `echorc.x -template $EXPID $wrt_ana[1] $wrt_ana[2] upper-air_bkg_filename`
                     set ifile  = `echorc.x -template $EXPID $wrt_ana[1] $wrt_ana[2] upper-air_inc_filename`
  
                     # Move all backgrounds to naming indicating iteration
                     # Special-handle bkg at initial time
                     rndasfiles $EXPID bkg.eta $beg_ana[1] $beg_ana[2] \
                                                           $end_ana[1] $end_ana[2] $ASYNBKG $viterp1
                     rndasfiles $EXPID bkg.sfc $beg_ana[1] $beg_ana[2] \
                                                           $end_ana[1] $end_ana[2] $ASYNBKG $viterp1
                     rndasfiles $EXPID cbkg.eta $beg_ana[1] $beg_ana[2] \
                                                           $end_ana[1] $end_ana[2] $ASYNBKG $viterp1
                     rndasfiles $EXPID abkg.eta $beg_ana[1] $beg_ana[2] \
                                                           $end_ana[1] $end_ana[2] $ASYNBKG $viterp1

                     @ thishrs = $wrt_ana[2] / 10000
                     set hh    = `echo $thishrs |awk '{printf "%02d", $1}'`
                     if ( -e rstupd.rc.tmpl ) then
                     #
                     # do nothing for now
                     #
                     else # < rstupd.rc.tmpl >
                        $RUN_OPT_BLEND -dynrst   fvcore_internal_rst \
                                       -moistrst moist_internal_rst  \
                                       -pchemrst pchem_internal_rst  \
                                       -sfc      $sfile \
                                       -bkg      $bfile \
                                       -inc      $ifile \
                                       -topo     topo_dynave.data \
                                       -nymd     $wrt_ana[1] -nhms $wrt_ana[2] \
                                       -tag      ana
                        if ( ${status} ) then
                            Call AbnormalExit_( 4 )
                        endif
 
                        /bin/cp -f fvcore_internal_rst.ana.${wrt_ana[1]}_${hh}z fvcore_internal_rst &
                        /bin/cp -f  moist_internal_rst.ana.${wrt_ana[1]}_${hh}z  moist_internal_rst &
                        /bin/cp -f  pchem_internal_rst.ana.${wrt_ana[1]}_${hh}z  pchem_internal_rst &
                        /bin/cp -f  $bfile  $afile &
                        wait
                        /bin/mv -f fvcore_internal_rst.ana.${wrt_ana[1]}_${hh}z $EXPID.ana.fvcore_internal_rst.${wrt_ana[1]}_${hh}z.$RSTSUFFIX
                        /bin/mv -f  moist_internal_rst.ana.${wrt_ana[1]}_${hh}z  $EXPID.ana.moist_internal_rst.${wrt_ana[1]}_${hh}z.$RSTSUFFIX
                        /bin/mv -f  pchem_internal_rst.ana.${wrt_ana[1]}_${hh}z  $EXPID.ana.pchem_internal_rst.${wrt_ana[1]}_${hh}z.$RSTSUFFIX
   
                        rndasfiles -purge -sfx $RSTSUFFIX $EXPID ana.fvcore_internal_rst $wrt_ana[1] $wrt_ana[2] \
                                                                                         $wrt_ana[1] $wrt_ana[2] 0 $viterp1
                        rndasfiles -purge -sfx $RSTSUFFIX $EXPID ana.moist_internal_rst  $wrt_ana[1] $wrt_ana[2] \
                                                                                         $wrt_ana[1] $wrt_ana[2] 0 $viterp1
                        rndasfiles -purge -sfx $RSTSUFFIX $EXPID ana.pchem_internal_rst  $wrt_ana[1] $wrt_ana[2] \
                                                                                         $wrt_ana[1] $wrt_ana[2] 0 $viterp1
                     endif # < rstupd.rc.tmpl >

                     rndasfiles -purge $EXPID inc.eta $wrt_ana[1] $wrt_ana[2] \
                                                      $wrt_ana[1] $wrt_ana[2] 0 $viterp1
                     rndasfiles -purge $EXPID ana.eta $wrt_ana[1] $wrt_ana[2] \
                                                      $wrt_ana[1] $wrt_ana[2] 0 $viterp1

                 endif # < WCONSTRAINT >

              endif # < IAU/4DVAR >

         endif  # < DOETA2BIN >

#        Signal successful completion
#        ----------------------------
         touch $FVWORK/.DONE_MEM001_CoupleAnaToGcm_${Viter_}.${ddz}${hhz}

                              # Last line of CoupleAnaToGcm_()

\end

#.............................................................................

# ------------------------------
  Sub IDFUpdate_( Final_ )
# ------------------------------
  if ( $?ECHO___ ) set echo

     if ( ! $Final_  ) exit 0
     if ( ! $DO4DVAR ) exit 0

     if ( -e IDFUPD.rc.tmpl ) then
                
         set idfb   = `echorc.x -rc IDFUPD.rc.tmpl DFIB_INTERNAL_RESTART_FILE`
         set idfa   = `echorc.x -rc IDFUPD.rc.tmpl DFIA_INTERNAL_RESTART_FILE`

         set hhmm = `echo ${wrt_rst_nhms} | cut -c1-4`

         if ( -e $idfb && -e $idfa ) then 

            /bin/rm -f sed_file
            echo "s/>>>IOBBKGD<<</${wrt_rst_nymd}/1"  >> sed_file
            echo "s/>>>IOBBKGT<<</${wrt_rst_nhms}/1"  >> sed_file
            echo "s/>>>IOBBKGH<<</${hhmm}/1"          >> sed_file
            echo "s/>>>IOEDATE<<</${gcm_nymdb}/1"     >> sed_file
            echo "s/>>>IOETIME<<</${gcm_nhmsb}/1"     >> sed_file
            /bin/rm -f ./IDFUPD.rc
            sed -f sed_file  ./IDFUPD.rc.tmpl  > ./IDFUPD.rc

             $idfupdx
             if ( ${status} ) then
                  Call AbnormalExit_( 4 )
             endif

         else
             echo "Failed to find IDF background and/or analysis file(s)"
             Call AbnormalExit_( 4 )
         endif

         set idfdyn = `echorc.x -rc IDFUPD.rc DYN_INTERNAL_CHECKPOINT_FILE`
         set idfmst = `echorc.x -rc IDFUPD.rc MOIST_INTERNAL_CHECKPOINT_FILE`
         set idfpch = `echorc.x -rc IDFUPD.rc PCHEM_INTERNAL_CHECKPOINT_FILE`
         set gcmdyn = `echorc.x -rc IDFUPD.rc DYN_INTERNAL_RESTART_FILE`
         set gcmmst = `echorc.x -rc IDFUPD.rc MOIST_INTERNAL_RESTART_FILE`
         set gcmpch = `echorc.x -rc IDFUPD.rc PCHEM_INTERNAL_RESTART_FILE`

         @ failed = 0
         if ( -e $idfdyn && -e $gcmdyn ) then
              /bin/mv $idfdyn $gcmdyn
         else
              @ failed ++
         endif
         if ( -e $idfmst && -e $gcmmst ) then
              /bin/mv $idfmst $gcmmst
         else
              @ failed ++
         endif
#        if ( -e $idfpch && -e $gcmpch ) then
#             /bin/mv $idfpch $gcmpch
#        else
#             @ failed ++
#        endif

         if ( $failed ) then
             echo "Cannot updated RSTs with IDF-initialized fields"
             Call AbnormalExit_( 4 )
         endif


     endif  # < IDF >

                              # Last line of IDFUpdate_()

\end

#.............................................................................

# ---------------------------------
  Sub UpdateAgcmResource4SplitExec_ ( Viter_, Final_ )
# ---------------------------------
  if ( $?ECHO___ ) set echo

#          Define AGCM to properly output desired restarts
#          -----------------------------------------------
           @ iterp1 = $Viter_ + 1
           set wrt_rst_nymd = $gcm_nymdb
           set wrt_rst_nhms = $gcm_nhmsb
           @ thishrs = $wrt_rst_nhms / 10000
           set wrt_rst_hr = `echo $thishrs |awk '{printf "%02d", $1}'` # two-digit hour this seg ends

           set ana0_hhmn = `echo $gcm_nhms0 |cut -c1-4` # two-digit hour this seg ends
           set ana0date     = ${gcm_nymd0}_${ana0_hhmn}
           set wrt_ana      = ( $gcm_nymd0 $gcm_nhms0 )
           set wrt_fcs_now  = ( `tick $gcm_nymd0 $gcm_nhms0  $aoffset_sec` )
           set wrt_fcs_nymd = $wrt_fcs_now[1]
           set wrt_fcs_nhms = $wrt_fcs_now[2]

#          Define time to write-out extra restart (normally used for fcst)
#          ---------------------------------------------------------------
           set fcs_nymdi = 37760704
           set fcs_nhmsi = 010000
           if ( ! `grep -c "@" saverst.rc` ) then
                set saverst   = `cat saverst.rc`
                set tot2store = `echo $#saverst`
                set id0       = 0
                while ( $id0 < $tot2store )
                   @ id0++
                   set saveme    = "$saverst[$id0]"
                   if ( "$wrt_fcs_nhms" == "${saveme}0000" ) then
                       set fcs_nymdi = $nymdb
                       set fcs_nhmsi = ${saveme}0000
                   endif
                end  # < id0 >
             endif  # < -e saverst.rc >

#          Define AGCM resource and time when to write out restarts
#          --------------------------------------------------------
           /bin/rm -f sed_file AGCM.rc AGCM.rc.HOLD
           if ( $DO4DVAR ) then
               if ( -e IDFUPD.rc.tmpl ) then # IDF ...
                  if ( $iterp1 == 1 ) then      # only need to write rst's at initial iteration of 3/4dvar procedure
                      set wrt_idf  = ( `tick $wrt_rst_nymd $wrt_rst_nhms $aoffset_sec` ) # only good for 6-hr ana
                      echo "s/>>>REFDATE<<</${wrt_rst_nymd}/1"  > sed_file
                      echo "s/>>>REFTIME<<</${wrt_rst_nhms}/1" >> sed_file
                      echo "s/>>>FCSDATE<<</${wrt_idf[1]}/1"   >> sed_file
                      echo "s/>>>FCSTIME<<</${wrt_idf[2]}/1"   >> sed_file
                  else
                       echo "s/>>>REFDATE<<</37760704/1"         > sed_file
                       echo "s/>>>REFTIME<<</010000/1"          >> sed_file
                       echo "s/>>>FCSDATE<<</37760704/1"        >> sed_file # do not write out rst for fcst
                       echo "s/>>>FCSTIME<<</010000/1"          >> sed_file
                  endif
                  echo "s/>>>RECFINL<<</YES/1"                 >> sed_file # need final state to get IDF rst
               else # no IDF ...
                  if ( $Final_ ) then        # only need to write rst's at last iteration of 3/4dvar procedure
                       echo "s/>>>REFDATE<<</${wrt_rst_nymd}/1"  > sed_file
                       echo "s/>>>REFTIME<<</${wrt_rst_nhms}/1" >> sed_file
                       echo "s/>>>FCSDATE<<</${fcs_nymdi}/1"    >> sed_file
                       echo "s/>>>FCSTIME<<</${fcs_nhmsi}/1"    >> sed_file
                  else
                       echo "s/>>>REFDATE<<</37760704/1"         > sed_file
                       echo "s/>>>REFTIME<<</010000/1"          >> sed_file
                       echo "s/>>>FCSDATE<<</37760704/1"        >> sed_file # do not write out rst for fcst
                       echo "s/>>>FCSTIME<<</010000/1"          >> sed_file
                  endif
                  echo "s/>>>RECFINL<<</NO/1"                   >> sed_file # do not write out final state (since in 4dvar we run one extra dt)
               endif # <IDF>
               if ( $WCONSTRAINT && $Viter_ ) then
                    if ( $DO4DIAU ) then
                       echo "s/>>>4DIAUDAS<<<//1"               >> sed_file # all iterations but 1st, run forced GCM w/ 4dIAU
                       echo "s/>>>FORCEDAS<<</#/1"              >> sed_file # all iterations but 1st, run forced GCM
                    else
                       echo "s/>>>4DIAUDAS<<</#/1"              >> sed_file # all iterations but 1st, run forced GCM
                       echo "s/>>>FORCEDAS<<<//1"               >> sed_file # all iterations but 1st, run forced GCM w/ 3dIAU
                    endif
               else
                    echo "s/>>>4DIAUDAS<<</#/1"                 >> sed_file # if 1st iteration run free GCM
                    echo "s/>>>FORCEDAS<<</#/1"                 >> sed_file # if 1st iteration run free GCM
               endif
           else # not 4dvar
               echo "s/>>>REFDATE<<</${wrt_rst_nymd}/1"  > sed_file # actual date to write rst for next cycle
               echo "s/>>>REFTIME<<</${wrt_rst_nhms}/1" >> sed_file # actual time to write rst for next cycle
               if ( $MKRESRST ) then
                     echo "s/>>>RECFINL<<</YES/1"             >> sed_file # write out checkpoint rst
               else 
                     echo "s/>>>RECFINL<<</NO/1"              >> sed_file # do not write out checkpoint rst
               endif
               echo "s/>>>FCSDATE<<</${fcs_nymdi}/1"    >> sed_file # date of extra restart (normally for fcst)
               echo "s/>>>FCSTIME<<</${fcs_nhmsi}/1"    >> sed_file # time of extra restart (normally for fcst)
               if ( $DOIAU || $FORECAST ) then
                    if ( $DO4DIAU ) then
                       echo "s/>>>FORCEDAS<<</#/1"          >> sed_file # force gcm w/ IAU increment
                       echo "s/>>>4DIAUDAS<<<//1"           >> sed_file # no 4d-tendency
                    else
                       echo "s/>>>FORCEDAS<<<//1"           >> sed_file # force gcm w/ IAU increment
                       echo "s/>>>4DIAUDAS<<</#/1"          >> sed_file # no 4d-tendency
                    endif
               else
                    echo "s/>>>FORCEDAS<<</#/1"             >> sed_file # run free gcm
                    echo "s/>>>4DIAUDAS<<</#/1"             >> sed_file # no 4d-tendency
               endif
           endif # <DO4DVAR>
           if ( $WCONSTRAINT ) then  # WCONSTRAINT for now only controls FGAT
                                     # in this case, ana writes inc in middle
                                     # of time period
             @ tauanl = $VAROFFSET * 60
             set wrt_inc = ( `tick $wrt_ana[1] $wrt_ana[2] $tauanl` )
             echo "s/>>>ANADATE<<</${wrt_inc[1]}/1" >> sed_file
             echo "s/>>>ANATIME<<</${wrt_inc[2]}/1" >> sed_file
           else # if not weak constraint ...
             if ( $DOIAU ) then
                echo "s/>>>ANADATE<<</${nymdb}/1"      >> sed_file
                echo "s/>>>ANATIME<<</${nhmsb}/1"      >> sed_file
             else
                echo "s/>>>ANADATE<<</${wrt_ana[1]}/1" >> sed_file
                echo "s/>>>ANATIME<<</${wrt_ana[2]}/1" >> sed_file
             endif
           endif # <WCONSTRAINT>
           echo "s/>>>NCSUFFIX<<</${NCSUFFIX}/1"   >> sed_file
           echo "s/>>>FORCEGCM<<</#/1"             >> sed_file
           echo "s/>>>REGULAR_REPLAY_ECMWF<<</#/1" >> sed_file
           echo "s/>>>REGULAR_REPLAY_NCEP<<</#/1"  >> sed_file
           echo "s/>>>REGULAR_REPLAY_GMAO<<</#/1"  >> sed_file
           echo "s/>>>REGULAR_REPLAY<<</#/1"       >> sed_file
           echo "s/>>>ITER<<</$Viter_/1"           >> sed_file
           echo "s/>>>ANA0YYYYMMDDHHMN<<</$ana0date/1" >> sed_file

           if ( -e AGCM_${Viter_}.rc.tmpl ) then
              sed -f sed_file  ./AGCM_${Viter_}.rc.tmpl > ./AGCM.rc
           else
              sed -f sed_file  ./AGCM.rc.tmpl          > ./AGCM.rc
           endif
           if ( $BOOTSTRAP ) sed -f sed_file  ./AGCM.rc.tmpl.HOLD        > ./AGCM.rc.HOLD
           cat AGCM.rc

\end
#.............................................................................

# --------------------------------
  Sub UpdateCapResource4SplitExec_ ( Final_ )
# --------------------------------
  if ( $?ECHO___ ) set echo

#          Which CAP to use?
#          -----------------
           set hh = `echo $gcm_nhms0 | cut -c1-2`
           if ( $Final_ ) then
              set mycap = CAP.rc.tmpl
              if ( -e CAP_${hh}.rc.tmpl ) set mycap = CAP_${hh}.rc.tmpl
           else
              set mycap = CAP.rc.tmpl
           endif

#          Define CAP to run GCM for proper length of time
#          -----------------------------------------------
           if ( $SHORTFCST && (! $Final_) ) then

                set job_sgmt = `grep -i JOB_SGMT $mycap`
                /bin/rm -f sed_file CAP.rc
                echo "s/$job_sgmt/JOB_SGMT: 0 030000/1"   > sed_file
                sed -f sed_file  ./$mycap                     > ./CAP.rc

#               Don't need any model output during the short-time forecast
#               ----------------------------------------------------------
                /bin/rm -f sed_file
                echo "EXPID:  $EXPID "   > sed_file
                echo "EXPDSC: $EXPID "  >> sed_file
                /bin/mv sed_file ./HISTORY.rc

           else
                /bin/cp $mycap CAP.rc
           endif

           if(-e ExtData.rc )    /bin/rm -f   ExtData.rc
           cd $FVHOME/run/gocart
           set  extdata_files = `/bin/ls -1 *_ExtData.rc`
           cat $extdata_files > $FVWORK/ExtData.rc
           cd -
           if ( ${gcm_nymd0}${hh} >= 2021103021 ) then
              foreach line (`grep -ni qfed ExtData.rc | gawk '{print $1}' FS=":"`)
                 sed -i "${line}s/.006./.061./" ExtData.rc
              end
           endif
           /bin/cp ExtData.rc $EXPID.ExtData.$itime.rc

                              # Last line of CoupleAnaToGcm_()
\end

#.............................................................................

# ------------------------------
  Sub SplitExecGcmRun_( Final_ )
# ------------------------------
  if ( $?ECHO___ ) set echo

#        Save desired restart files to use for forecasting purposes
#        ----------------------------------------------------------
         set final_fcst = 0
         if ( $nsegs == 1 ) then
              /bin/mv saverst.rc  saverst.rc.orig
              if ( $AGCMFCST ) then
                   set savetest1 = `echo $itime | cut -c 10-11`
                   set savetest2 = `tick 20010101 ${savetest1}0000 10800 |  cut -c10-11`
                   set savetest3 = `tick 20010101 ${savetest1}0000 21600 |  cut -c10-11` 
                   set save_rst = ()
                   if ( `grep -c $savetest1 saverst.rc.orig` ) set save_rst = ( $savetest1 )
                   if ( `grep -c $savetest2 saverst.rc.orig` ) set save_rst = ( $save_rst $savetest2 )
                   if ( `grep -c $savetest3 saverst.rc.orig` ) set final_fcst = 1 
                   if ( $#save_rst ) echo $save_rst >! saverst.rc
                   if ( ( -e saverst.rc ) && ( ! -z saverst.rc ) )  then
                        if ( `grep -c $savetest2 saverst.rc.orig` ) then
                              set fcs_nymdi = $nymdb
                              set fcs_nhmsi = $nhmsb
                        else  
                              set fcs_nymdi = 22000101
                              set fcs_nhmsi = 000000
                        endif 
                   else 
                        echo "@saverst" >! saverst.rc
                   endif
              else 
                    set final_fcst = 0
                    set savetest = `echo ${nhmsb} | cut -c1-2`
                    if ( `grep -c $savetest saverst.rc.orig` ) then
                         echo "$savetest" >! saverst.rc
                         set fcs_nymdi = $nymdb
                         set fcs_nhmsi = $nhmsb
                 else
                         echo "@saverst" >! saverst.rc
                 endif
            endif
         endif

         if ( (! $VAROFFSET ) ) then   # in case of running intermittent analysis update
            if ( ( ! `grep -c "@" saverst.rc` ) && ( ! $AGCMFCST ) ) then
              zeit_ci.x SaveRS
              set saverst   = `cat saverst.rc`
              set tot2store = `echo $#saverst`
              set id0       = 0
              while ( $id0 < $tot2store )
                 @ id0++ 
                 set saveme = "$saverst[$id0]"
                 set fcs_nymdi = $nymdb
                 set fcs_nhmsi = ${saveme}0000
                 if ( $nhmsb == $fcs_nhmsi ) then
                   foreach rs ( $grs_list ) 
                     if ( -e ${rs}_rst && ! -e $EXPID.${rs}_rst.${nymdb}_${saveme}z.$RSTSUFFIX ) \
                        /bin/cp  ${rs}_rst $EXPID.${rs}_rst.${nymdb}_${saveme}z.$RSTSUFFIX &
                   end
                   /bin/cp -f biasinp.bin $EXPID.biasinp_rst.${nymdb}_${saveme}z.$RSTSUFFIX &
                   /bin/cp -f biasinp.ctl $EXPID.biasinp_rst.${nymdb}_${saveme}z.ctl &
                   wait
                   if ( ! -e $EXPID.rst.lcv.${nymdb}_${saveme}z.bin ) \
                        mkdrstdate.x ${nymdb} ${saveme}0000 $EXPID.rst.lcv.${nymdb}_${saveme}z.bin
                 endif # < iau >
              end  # < id0 >
              zeit_co.x SaveRS
            endif  # < -e saverst.rc >
         endif  # < not varoffset >

#        Launch zipping job
#        ------------------
         if ( $DOFREPACK ) then
             setenv  REPACK_PBS `$REPACK_PBS_CMD`
             if ( $BATCH_SUBCMD == "sbatch" ) then
                echo $REPACK_PBS >! ${FVHOME}/.REPACK_PBS.${SLURM_JOBID}
             else
                echo $REPACK_PBS >! ${FVHOME}/.REPACK_PBS.${PBS_JOBID}
             endif
         else
             setenv  REPACK_PBS 0
         endif

#        Run GCM
#        -------
         if ( $CENTRAL_AGCM_PARALLEL ) then

            setenv MYNAME "SplitExecGcmRun"
            setenv FAILED 0
            if (!($?CENTRAL_AGCM_QNAME)     ) setenv FAILED 1
            if (!($?CENTRAL_AGCM_WALLCLOCK) ) setenv FAILED 1
            jobgen.pl \
                 -egress EGRESS  -q $CENTRAL_AGCM_QNAME \
                 agcm_central        \
                 $GID                \
                 $CENTRAL_AGCM_WALLCLOCK    \
                 "$dryrun $run_opt_begin |& tee -a $FVWORK/fvpsas.log" \
                 $FVWORK             \
                 $MYNAME             \
                 $FVWORK/.DONE_CENTRAL_${MYNAME}.$yyyymmddhh \
                 "Central AGCM Failed "
    
                 if ( -e agcm_central.j ) then
                    if ( $BATCH_SUBCMD == "sbatch" ) then
                       sbatch -W agcm_central.j
                    else
                       qsub -W block=true agcm_central.j
                    endif
                 else
                    echo " ${MYNAME}: AGCM Failed to generate PBS jobs for Central, Aborting ... "
                    exit(1)
                 endif

         else
            set use_shmem = `echorc.x -rc CAP.rc USE_SHMEM`
            if ( $use_shmem ) RmShmKeys_sshmpi.csh
            /bin/rm -f ./EGRESS
                                   zeit_ci.x gcm
            $dryrun $run_opt_begin |& tee -a fvpsas.log
            echo "GCM status = $status"
                                   zeit_co.x gcm
            if ( $use_shmem ) RmShmKeys_sshmpi.csh
         endif

#        Capture exit status
#        -------------------        
         $dryrun ls ./EGRESS
         set model_status = $status
         if ( $model_status ) then
             Call AbnormalExit_( 2 )
         endif

         ls -lrt # _RT (removed this later)

#        Update d_rst
#        ------------
         if ( $Final_ ) then
             /bin/rm d_rst
             mkdrstdate.x $wrt_rst_nymd $wrt_rst_nhms    # create d_rst with current date and time
         endif
         /bin/rm -r       cap_restart                    # make sure and redefine cap_restart
         rst_date d_rst > cap_restart

                              # Last line of SplitExecGcmRun_() 
\end

#.............................................................................

# ------------------------------
  Sub InitAerosolAnalysis_()
# ------------------------------
  if ( $?ECHO___ ) set echo

# check for required environment variables
# ----------------------------------------
  if (! $?NCPUS) then
     echo ">> Error << ${name}: Environment variable $NCPUS not defined"
     exit
  endif

  if (! $?NCPUS_GSI) then
     echo ">> Error << ${name}: Environment variable $NCPUS_GSI not defined"
     exit
  endif

# determine whether to run aerosol analysis in parallel with gsi
# --------------------------------------------------------------
  if ( ! $?NCPUS_AOD ) then
     setenv NCPUS_AOD 1
  endif

  @ xtra = $NCPUS - $NCPUS_GSI

  if ($xtra < $NCPUS_AOD) then
     setenv aod_parallel_flag 0
  else
     setenv aod_parallel_flag 1
  endif

  if ($GAAS_RUN_SLURM) setenv aod_parallel_flag 0

# write node files for ana and aod, if parallel
# ---------------------------------------------
  if ($aod_parallel_flag) then
     #echo "cat PBS_NODEFILE"
     #cat $PBS_NODEFILE

     if ($?NCPUS_PER_NODE) then
        set ppnflg = "-ppn $NCPUS_PER_NODE"
     else
        set ppnflg = ""
     endif

     subset_nodefile.pl $NCPUS_GSI -f $PBS_NODEFILE -o $FVWORK/ANA_list $ppnflg
     #echo "cat FVWORK/ANA_list"
     #cat $FVWORK/ANA_list

     subset_nodefile.pl $NCPUS_AOD -f $PBS_NODEFILE -back -o $FVWORK/AOD_list $ppnflg
     #echo "cat FVWORK/AOD_list"
     #cat $FVWORK/AOD_list
  endif

# initial date/time for gaas_bkg.sfc files
# ----------------------------------------
  set rstdate = ( `rst_date d_rst` )
  set gaasDateTimeBeg = ( `tick $rstdate 0 030000` )
  set gaasDateBeg = $gaasDateTimeBeg[1]
  set gaasTimeBeg = $gaasDateTimeBeg[2]

                             # Last line of InitAerosolAnalysis_()
\end

#.............................................................................

# ------------------------------
  Sub AerosolAnalysis_( )
# ------------------------------
  if ( $?ECHO___ ) set echo

  if ( ! $GAAS_ANA ) exit 0

  if ( $DO4DVAR ) then
     set aod_date = $IgaasDateBeg
     set aod_time = $IgaasTimeBeg
  else
     set aod_date = $gaasDateBeg
     set aod_time = $gaasTimeBeg
  endif

  # Set up separate work directory
  # ------------------------------  
  setenv AODWORK $FVWORK/aod.$aod_date.$aod_time
  mkdir $AODWORK
  touch $AODWORK/.no_archiving

  # Copy over pcf files for NNR
  # ---------------------------
  /bin/cp $FVHOME/run/gaas/avhrr_l2a.pcf $AODWORK
  /bin/cp $FVHOME/run/gaas/modis_l2a.pcf $AODWORK

  # Reset value of MODIS_L2A_L2_DIR to $MODIS_STAGE_DIR?
  # ---------------------------------------------------
  if ($GAAS_ANA && $USE_MODIS_STAGE) then
      if ( ! $?MODIS_STAGE_DIR ) then
         echo "Error. MODIS_STAGE_DIR not defined"
         echo "Aborting ... "
         Call AbnormalExit_( 5 )
      endif
      if ( ! -d $MODIS_STAGE_DIR ) then
         echo "Error. MODIS_STAGE_DIR directory not found: $MODIS_STAGE_DIR"
         echo "Aborting ... "
         Call AbnormalExit_( 5 )
      endif
      vED -i -vv MODIS_L2A_L2_DIR=$MODIS_STAGE_DIR $AODWORK/modis_l2a.pcf
  endif

  # Prepare ana.rc from template
  # ----------------------------
  set ana_rc_tmpl = $FVHOME/run/gaas/ana.rc.tmpl
  set ana_rc = $AODWORK/ana.rc
  vED -env $ana_rc_tmpl -o $ana_rc

  if ($SKIP_PSAS) then
     vED -i -vv do_you_want_to_skip_PSAS=yes $ana_rc
  else
     vED -i -vv do_you_want_to_skip_PSAS=no $ana_rc
  endif

  if (! $?AERO_OBSDBRC) setenv AERO_OBSDBRC obsys-gaas.rc
  @ numhrs = $nstep * 6
  set rcflag = "-rc $AERO_OBSDBRC"
  set patmosxFLG = 0
  set aod_obclass = `obsclass_filter.pl $rcflag $AOD_OBSCLASS $bnymd $bnhms $numhrs`
  set aod_obs_list = (`echo $aod_obclass | sed "s/,/ /g"`)

  setenv MODIS_L2_HDF 0
  foreach aod_obs ($aod_obs_list)
     if ($aod_obs == 0) continue
     if ($aod_obs == patmosx_asc) then
        set patmosxFLG = 1
        sed -i "s/#___AVHRR___//" $ana_rc
     endif

     if ($aod_obs == patmosx_asc)     sed -i "s/#___AVHRR___//"   $ana_rc
     if ($aod_obs == aeronet_obs)     sed -i "s/#___AERONET___//" $ana_rc
     if ($aod_obs == misr_F12_bright) sed -i "s/#___MISR___//"    $ana_rc
     if ($aod_obs == mod04_land_nnr)  sed -i "s/#___TERRA___//"   $ana_rc
     if ($aod_obs == myd04_land_nnr)  sed -i "s/#___AQUA___//"    $ana_rc

     set dtype = `$FVROOT/bin/aod_data.py aod_type $aod_obs $AERO_OBSDBRC`

     if ($dtype == "aqua_L2") then
        setenv MODIS_L2_HDF 1
        sed -i "s/#___AQUA_NRT___//" $ana_rc
     endif

     if ($dtype == "terra_L2") then
        setenv MODIS_L2_HDF 1
        sed -i "s/#___TERRA_NRT___//" $ana_rc
     endif
  end

#  if ($USE_MODIS_STAGE) then
#     setenv MODIS_L2_HDF 1
#     sed -i "s/#___AQUA_NRT___//"  $ana_rc
#     sed -i "s/#___TERRA_NRT___//" $ana_rc
#  endif

  echo "cat $ana_rc"
  cat $ana_rc

  # copy other resource files and aerosol bkgs to work directory
  # ------------------------------------------------------------
  \cp $FVHOME/run/gaas/*.rc $AODWORK

  foreach aod_time_offset ( 000000 030000 )
     set gaastime = (`tick $aod_date $aod_time 0 $aod_time_offset`)
     set ymd = $gaastime[1]
     set hms = $gaastime[2]

     set flg1 = "-template $EXPID $ymd $hms"
     set flg2 = "-rc $AODWORK/gaas.rc gaas_bkg_filename"
     set aer_f = `echorc.x $flg1 $flg2`
     echo $aer_f

     if ($aer_f == "") then  # this test is to catch funk behavior under MPT where sometime env not correct
        echo "file $aer_f not found in $AODWORK, aborting ... "
        exit 1
     endif

     /bin/cp $aer_f $AODWORK
  end

# write job script to AODWORK
# ---------------------------
  set tmpl = "$FVHOME/run/gaas/ana_aod.j.tmpl"
  set jobf = "$AODWORK/ana_aod.j"
  set aod_label = `echo ${aod_date}_${aod_time} | cut -c1-11`
  set gaasLOG  = $FVWORK/${EXPID}.ana_aod.log.${aod_label}z.txt
  set gaasLOGx = $FVHOME/run/ana_aod.abnormal.log.${aod_label}z.txt

  set siteID = `$FVROOT/bin/get_siteID.pl`
  set nodeflg = ""
  if ($siteID == "nas") then
     if ($NCPUS_PER_NODE == 12) set nodeflg = ":model=wes"
     @ num_aod_nodes = $NCPUS_AOD / $NCPUS_PER_NODE
     if ( $num_aod_nodes * $NCPUS_PER_NODE < $NCPUS_AOD ) @ num_aod_nodes++
     set pbsflg1 = "select=$num_aod_nodes"
     set pbsflg2 = "ncpus=$NCPUS_PER_NODE"
     set pbsflg3 = "mpiprocs=$NCPUS_PER_NODE"
     set line5 = "#PBS -l ${pbsflg1}:${pbsflg2}:$pbsflg3$nodeflg"
     set line6 = "#"
  else
     set line5 = "#SBATCH --ntasks=$NCPUS_AOD"
     set line6 = "#PBS -l ncpus=$NCPUS_AOD"

  endif
  set npn = `facter processorcount`
  if ( $npn == 40 ) then
     set mynodes = "sky"
  else if ( $npn == 48 ) then
     set mynodes = "cas"
  else
     set mynodes = "hasw"
  endif

  setenv GAASFAIL $AODWORK/ana_aod.FAILED.$$
  touch $GAASFAIL

  sed -e 5i"$line5" < $tmpl >! $jobf
  sed -i 6i"$line6" $jobf
  sed -i "s|>>>PATMOSX<<<|${patmosxFLG}|" $jobf
  sed -i "s|>>>MODIS_L2_HDF<<<|${MODIS_L2_HDF}|" $jobf

  sed -i "s|>>>MYNODES<<<|${mynodes}|" $jobf
  sed -i "s|>>>AODWORK<<<|${AODWORK}|" $jobf
  sed -i "s|>>>FVHOME<<<|${FVHOME}|" $jobf
  sed -i "s|>>>FVWORK<<<|${FVWORK}|" $jobf
  sed -i "s|>>>GAASFAIL<<<|${GAASFAIL}|" $jobf
  sed -i "s|>>>MPIRUN_PSAS<<<|${MPIRUN_AOD}|" $jobf
  sed -i "s|>>>MPIRUN_AOD<<<|${MPIRUN_AOD}|" $jobf
  sed -i "s|>>>NCPUS_AOD<<<|${NCPUS_AOD}|" $jobf
  sed -i "s|>>>NYMD<<<|${aod_date}|" $jobf
  sed -i "s|>>>NHMS<<<|${aod_time}|" $jobf
 
  echo "cat $jobf"
  if ($status) then
     exit 1
  endif
  #cat $jobf

  if ($aod_parallel_flag) then
     /bin/cp $FVWORK/AOD_list $AODWORK

     # run at command line
     #--------------------
     chmod 744 $jobf
     $jobf $aod_parallel_flag >&! $gaasLOG &

  else

     # submit job and save job ID
     #---------------------------
     if ( $BATCH_SUBCMD == "sbatch" ) then
         set qblock = "-W"
     else
         set qblock = "-W block=true"
     endif
     if ( $AODBLOCKJOB ) then
        set jobIDline = (`$PBS_BIN/$BATCH_SUBCMD $qblock -o $gaasLOG $jobf`)
     else
        set jobIDline = (`$PBS_BIN/$BATCH_SUBCMD -o $gaasLOG $jobf`)
     endif
     set jobID = $jobIDline[$#jobIDline]

     if ($?aodJobIDs) then
        setenv aodJobIDs "${aodJobIDs}:$jobID"
     else
        setenv aodJobIDs $jobID
     endif

  endif

                              # Last line of AerosolAnalysis_()
\end

#.............................................................................

# ------------------------------
  Sub RenameRstCheckPoint_( Final_ )
# ------------------------------
  if ( $?ECHO___ ) set echo


        if ( ( $BOOTSTRAP ) && ( $seg == 0 ) ) then 
             setenv BOOTSTRAP 0
             mv -f ./AGCM.rc.tmpl.HOLD ./AGCM.rc.tmpl
             mv -f ./AGCM.rc.HOLD ./AGCM.rc
             cat ./AGCM.rc
             set grs_list = ( `grs_list.pl -rc AGCM.rc` )
        endif

#       Move checkpoint files into restart files
#       ----------------------------------------
        @ mystat = 0
        if ( $Final_ ) then

           @ id = 0
           @ mystat = 0
           set rstot = `echo $#grs_list`
           set timestamp = ${wrt_rst_nymd}_${wrt_rst_hr}

           while ( $id < $rstot )
               @ id++
               set rsType = $grs_list[$id]
               if ( $rsType == agcm_import || $rsType == agcm_internal || $rsType == aiau_import ) continue

               set GCMrst    = ${rsType}_rst
               set GCMrst_TS = ${GCMrst}.${timestamp}z.$RSTSUFFIX

               # intermittent 6-hr analysis case
               if ( $ASYNBKG == 360 ) then
                   set checkpoint = ${rsType}_checkpoint
               else
                   set checkpoint = ${rsType}_checkpoint.${timestamp}00z.$RSTSUFFIX
               endif

               if (-e $checkpoint) then
                   /bin/mv $checkpoint $GCMrst
                   @ mystat = ( ${mystat}$status )

                   if ( $nsegs == 1 ) then
                       /bin/mv $GCMrst ${EXPID}.$GCMrst_TS &
                   else
                       /bin/cp $GCMrst $GCMrst_TS &
                   endif
               else
                   @ mystat = ( ${mystat}1 )
               endif
           end
           wait
        endif  # < $Final_ >

        if ( $mystat ) then
            Call AbnormalExit_( 2 )
        endif
                              # Last line of RenameRstCheckPoint_() 
\end

#.............................................................................

# ------------------------------
  Sub SingleExecGcmRun_()
# ------------------------------
  if ( $?ECHO___ ) set echo

   if ($ihh0 >= 0 ) then
       set mycap = CAP_${ihh0}.rc.tmpl
   else
       set mycap = CAP.rc.tmpl
   endif

# Set parameters for GCM resume restarts
# --------------------------------------
   if ( $MKRESRST ) then
        set fcst_beg = ( `rst_date d_rst` )
        set nymdt   = $fcst_beg[1]
        set nhmst   = $fcst_beg[2]
        set nd_nh = ( `grep -i JOB_SGMT $mycap | awk '{printf "%d %d",$2, $3}'` )
        set nsecs = `(expr $nd_nh[1] \* 86400 \+ $nd_nh[2] \/ 10000 \* 3600)`
        set fcst_end = ( `tick $fcst_beg $nsecs` )
   endif

   if ( $FORECAST ) then
 
#       Which CAP to use?
#       -----------------
        set hh = `echo $gcm_nhms0 | cut -c1-2`

        set fcst_beg = ( `rst_date d_rst` )
        set nymdt   = $fcst_beg[1]
        set nhmst   = $fcst_beg[2]
        set hhmnt   = `echo $nhmst | cut -c1-4`
        set nd_nh = ( `grep -i JOB_SGMT $mycap|awk '{printf "%d %d",$2, $3}'` )
        set nsecs = `(expr $nd_nh[1] \* 86400 \+ $nd_nh[2] \/ 10000 \* 3600)`
        set fcst_end = ( `tick $fcst_beg $nsecs` )

        set anadate = ( `tick $fcst_beg $foffset_sec` )

#       Define AGCM to properly output desired restarts
#       -----------------------------------------------
        /bin/rm -f sed_file AGCM.rc AGCM.rc.HOLD
        echo "s/>>>REFDATE<<</${fcs_nymdi}/1"        > sed_file
        echo "s/>>>REFTIME<<</${fcs_nhmsi}/1"       >> sed_file
        echo "s/>>>FCSDATE<<</${fcs_nymdi}/1"       >> sed_file
        echo "s/>>>FCSTIME<<</${fcs_nhmsi}/1"       >> sed_file
        echo "s/>>>RECFINL<<</NO/1"                 >> sed_file # do not write out final state
        echo "s/>>>NCSUFFIX<<</${NCSUFFIX}/1"       >> sed_file
        if ( $ifcst ) then
           if ( $DO4DIAU ) then
              echo "s/>>>4DIAUDAS<<<//1"            >> sed_file # no 4d-tendency for now
              echo "s/>>>FORCEDAS<<</#/1"           >> sed_file
           else
              echo "s/>>>4DIAUDAS<<</#/1"           >> sed_file # no 4d-tendency for now
              echo "s/>>>FORCEDAS<<<//1"            >> sed_file
           endif
           echo "s/>>>ANADATE<<</${initref[1]}/1"   >> sed_file
           echo "s/>>>ANATIME<<</${initref[2]}/1"   >> sed_file
        else
           echo "s/>>>4DIAUDAS<<</#/1"              >> sed_file # no 4d-tendency for now
           echo "s/>>>FORCEDAS<<</#/1"              >> sed_file
           echo "s/>>>ANADATE<<</${anadate[1]}/1"   >> sed_file
           echo "s/>>>ANATIME<<</${anadate[2]}/1"   >> sed_file
        endif
        echo "s/>>>FORCEGCM<<</#/1"                 >> sed_file
        if ( $blendrs || $blendec ) then

            echo "s/>>>REGULAR_REPLAY<<</ /1"       >> sed_file
           if ($blendrs) then
              echo "s/>>>REGULAR_REPLAY_ECMWF<<</#/1" >> sed_file
              echo "s/>>>REGULAR_REPLAY_NCEP<<</ /1"  >> sed_file
              echo "s/>>>REGULAR_REPLAY_GMAO<<</#/1"  >> sed_file
           endif

           if ($blendec) then
              echo "s/>>>REGULAR_REPLAY_ECMWF<<</ /1" >> sed_file
              echo "s/>>>REGULAR_REPLAY_NCEP<<</#/1"  >> sed_file
              echo "s/>>>REGULAR_REPLAY_GMAO<<</#/1"  >> sed_file
           endif

        else
            echo "s/>>>REGULAR_REPLAY_ECMWF<<</#/1" >> sed_file
            echo "s/>>>REGULAR_REPLAY_NCEP<<</#/1"  >> sed_file
            echo "s/>>>REGULAR_REPLAY_GMAO<<</#/1"  >> sed_file
            echo "s/>>>REGULAR_REPLAY<<</#/1"       >> sed_file
        endif
        set time0date = ${nymdt}_${hhmnt}
        echo "s/>>>ANA0YYYYMMDDHHMN<<</$time0date/1" >> sed_file

#  Pure model run, in DAS mode (no provisions for replay yet)
#  ----------------------------------------------------------
   else if ( $SKIPANA ) then

#       Beginning and end of run segment
#       --------------------------------
        set GcmBegDate = $GcmBegEpoch[1]
        set GcmBegTime = $GcmBegEpoch[2]
        set GcmEndDate = $GcmEndEpoch[1]
        set GcmEndTime = $GcmEndEpoch[2]
        
#       Which CAP to use?
#       -----------------
        set nymdt = $GcmBegEpoch[1]
        set hh = `echo $GcmBegTime | cut -c1-2`
        set myhist = HISTORY.rc.tmpl
        if ( -e HISTORY_${hh}.rc.tmpl ) set myhist = HISTORY_${hh}.rc.tmpl

#       Create HISTORY.rc
#       -----------------
        /bin/rm -f sed_file
        echo "s/>>>IOEDATE<<</$GcmEndDate/1"   > sed_file
        echo "s/>>>IOETIME<<</$GcmEndTime/1"  >> sed_file
        echo "s/>>>IOBBKGD<<</$GcmBegDate/1"  >> sed_file
        echo "s/>>>IOBBKGT<<</$GcmBegTime/1"  >> sed_file
        echo "s/>>>IOEBKGD<<</$GcmEndDate/1"  >> sed_file
        echo "s/>>>IOEBKGT<<</$GcmEndTime/1"  >> sed_file   
        echo "s/>>>NCSUFFIX<<</${NCSUFFIX}/1" >> sed_file
        /bin/rm -f HISTORY.rc
        sed -f sed_file  $myhist  > ./HISTORY.rc

#       Define AGCM rc files; output of desired restarts
#             probably broken 
#       -----------------------------------------------
        /bin/rm -f sed_file AGCM.rc AGCM.rc.HOLD
        echo "s/>>>REFDATE<<</$GcmBegDate/1"   > sed_file
        echo "s/>>>REFTIME<<</$GcmBegTime/1"  >> sed_file
        echo "s/>>>FCSDATE<<</${fcs_nymdi}/1" >> sed_file
        echo "s/>>>FCSTIME<<</${fcs_nhmsi}/1" >> sed_file
        echo "s/>>>NCSUFFIX<<</${NCSUFFIX}/1" >> sed_file
        if ( $ifcst ) then
           if ( $DO4DIAU ) then
              echo "s/>>>4DIAUDAS<<<//1"      >> sed_file # no 4d-tendency for now
              echo "s/>>>FORCEDAS<<</#/1"     >> sed_file
           else
              echo "s/>>>4DIAUDAS<<</#/1"     >> sed_file # no 4d-tendency for now
              echo "s/>>>FORCEDAS<<<//1"      >> sed_file
           endif
        else
           echo "s/>>>4DIAUDAS<<</#/1"        >> sed_file # no 4d-tendency for now
           echo "s/>>>FORCEDAS<<</#/1"        >> sed_file
        endif
        echo "s/>>>FORCEGCM<<</#/1"           >> sed_file
        echo "s/>>>REGULAR_REPLAY_ECMWF<<</#/1" >> sed_file
        echo "s/>>>REGULAR_REPLAY_NCEP<<</#/1"  >> sed_file
        echo "s/>>>REGULAR_REPLAY_GMAO<<</#/1"  >> sed_file
        echo "s/>>>REGULAR_REPLAY<<</#/1"       >> sed_file

# Single executable analysis
# --------------------------
  else

       echo $0": single executable analysis not implemented yet"
       exit 1

   endif # forecast or pure model run (without analysis)

#  Update AGCM rc files to properly output desired restarts
#  (for both Forecast and pure model run)
#  --------------------------------------------------------
   sed -f sed_file ./AGCM.rc.tmpl > ./AGCM.rc
   if ( $BOOTSTRAP ) sed -f sed_file ./AGCM.rc.tmpl.HOLD > ./AGCM.rc.HOLD
   cat AGCM.rc

   /bin/cp $mycap CAP.rc   # need to do better for MAP05/06 opt
   if(-e ExtData.rc )    /bin/rm -f   ExtData.rc
   cd $FVHOME/run/gocart
   set  extdata_files = `/bin/ls -1 *_ExtData.rc`
   cat $extdata_files > $FVWORK/ExtData.rc
   if ( ${nymdt}${hh} >= 2021103021 ) then
      foreach line (`grep -ni qfed $FVWORK/ExtData.rc | gawk '{print $1}' FS=":"`)
        sed -i "${line}s/.006./.061./" $FVWORK/ExtData.rc
      end
   endif
   cd -
#  /bin/cp ExtData.rc $EXPID.ExtData.$itime.rc

   /bin/rm -f ./EGRESS

# Launch zipping job
# ------------------
   if ( $DOFREPACK ) then
         setenv  REPACK_PBS `$REPACK_PBS_CMD`
         if ( $BATCH_SUBCMD == "sbatch" ) then
            echo $REPACK_PBS >! ${FVHOME}/.REPACK_PBS.${SLURM_JOBID}
         else
            echo $REPACK_PBS >! ${FVHOME}/.REPACK_PBS.${PBS_JOBID}
         endif
   else
         setenv  REPACK_PBS 0
   endif
                          zeit_ci.x gcm
   $dryrun $run_opt_begin |& tee fvpsas.log
                          zeit_co.x gcm

#  Check whether we ran without errors
#  -----------------------------------
   $dryrun ls ./EGRESS
   set model_status = $status
   if ( ${model_status} ) then
       Call AbnormalExit_( 2 )
   endif

   if ( $BOOTSTRAP) then
        setenv BOOTSTRAP 0
        set grs_list = ( `grs_list.pl -rc AGCM.rc.HOLD` )
   endif

                              # Last line of SingleExecGcmRun_() 
\end


#.............................................................................

# -------------------------------------
  Sub SplitExecVortexTrackerRun_()
# -------------------------------------
  if ( $?ECHO___ ) set echo

        set vtrtime = (`tick $nymdb $nhmsb 21600`) # need to test this w/o IAU
        set nymdt   = $vtrtime[1]
        set nhmst   = $vtrtime[2]

#       Check tcvitals for valid entries
#       (assumes tcvitals.yyyymmddhh naming convention)
#       ------------------------------------------------
        foreach vitals  ( `ls *tcvitals*` )
           echo "Checking $vitals for valid entries."
           cat $vitals
           set tcvdate = `echo $vitals | cut -d . -f2 | cut -c 1-8`
           set tcvtime = `echo $vitals | cut -d . -f2 | cut -c 9-10`00
           \rm -f ${vitals}.tmp
           mv $vitals ${vitals}.tmp
           cat ${vitals}.tmp | grep "$tcvdate $tcvtime" > $vitals
           echo "Corrected ${vitals}:"
           cat  $vitals
           \rm -f ${vitals}.tmp
        end

#       First run vortex tracking code ...
#       ----------------------------------
        if ( $VTRACK ) then
              vtrack -freq $VTRKFRQA -rc $FVWORK/vtrack.rc $nymdt $nhmst $EXPID
        endif

                              # Last line of SplitExecVortexTrackerRun_()
\end

#.............................................................................

# -------------------------------------
  Sub SingleExecVortexTrackerRun_()
# -------------------------------------
  if ( $?ECHO___ ) set echo

# Run vortex tracking code ... (does not yet work w/ FG5 option!)
# ---------------------------------------------------------------
  if ( $VTRACK ) then

     if ( -e CAP.rc ) then
        set jobsgmt = `echorc.x -rc CAP.rc JOB_SGMT`
        @ fcsthrs = ( $jobsgmt[1] * 24 ) + ( $jobsgmt[2] / 10000 )
        @ ndays   =   $jobsgmt[1] + 1
        @ fcstsec = $fcsthrs * 3600
        @ offset_hrs = $foffset_sec / 3600
        @ adjust_fcsthrs = $fcsthrs - $offset_hrs
        @ adjust_fcstsec = $adjust_fcsthrs * 3600
        set fvtrack_end = (`tick $nymd1 $nhms1 $adjust_fcstsec`)
        set nymde = $fvtrack_end[1]
        set nhmse = $fvtrack_end[2]
        set hhe = `echo $nhmse | cut -c1-2`
     else
        Call AbnormalExit_( 2 )
     endif
     set tcvitals_class = `grep tcvitals $FVHOME/run/obsys.rc | grep BEGIN | cut -d" " -f2`
     if (`uname -n` !~ borg*) then
        acquire_obsys -v -d $FVWORK $strict $anadate[1] $anadate[2] 060000 $ndays $tcvitals_class
        if ( $status ) then
           echo "Trouble determining TCVITALS observation class name"
        endif
     else

        set qsub_acquire = 1
        if (`uname -n` =~ borg*) then
           set data_queue=datamove
        else if (`uname -n` =~ r*i[0-3]n*) then
           set data_queue=normal
        else
           set data_queue=""
        endif

        set fname = "acq_tcv.pbs"
        set acqdate = ${anadate[1]}_`echo $anadate[2] | cut -c1-2`z
        set acqlog = $FVHOME/run/acq_tcv.log.$acqdate.txt
        fname1 "#\!/bin/csh -xvf"
        fname2 "#$group_list"
        fname2 "#SBATCH --job-name=acqblend"
        fname2 "#SBATCH --output=acqblend.log.$acqdate.txt"
        fname2 "#SBATCH --ntasks=1"
        fname2 "#SBATCH --time=2:00:00"
        fname2 "#SBATCH --partition=$data_queue"
        fname2 "#SBATCH --account=$GID"
        fname2 "#PBS -N acqblend"
        fname2 "#PBS -o acqblend.log.$acqdate.txt"
        fname2 "#PBS -l nodes=1:ppn=1"
        fname2 "#PBS -l walltime=2:00:00"
        fname2 "#PBS -q $data_queue"
        fname2 "#PBS -S /bin/csh"
        fname2 "#PBS -j eo"
        fname2 ""
        fname2 "setenv DO_DMGET $DO_DMGET"
        fname2 "set path = ( $path )"
        fname2 "cd $FVWORK"
        fname2 " acquire_obsys -v -d $FVWORK $strict $anadate[1] $anadate[2] 060000 1 $tcvitals_class"
        fname2 "exit"

        if ( $BATCH_SUBCMD == "sbatch" ) then
           sbatch -W -o $acqlog $fname
        else
           qsub -W block=true -o $acqlog $fname
        endif

     endif
     ls -lrt *vtx.prs* *vtx.mix*

#    Check tcvitals for valid entries
#    (assumes tcvitals.yyyymmddhh naming convention)
#    ------------------------------------------------
     set hh1g = `echo $nhms1g     | cut -c1-2` 
     set hha  = `echo $anadate[2] | cut -c1-2` 
     touch tcvitals.${anadate[1]}${hha}+${nymde}${hhe}
     foreach vitals  ( `ls *tcvitals*` )
        echo "Checking $vitals for valid entries."
        cat $vitals
        set tcvdate = `echo $vitals | cut -d . -f2 | cut -c 1-8`
        set tcvtime = `echo $vitals | cut -d . -f2 | cut -c 9-10`00
        \rm -f ${vitals}.tmp
        mv $vitals ${vitals}.tmp
        cat ${vitals}.tmp | grep "$tcvdate $tcvtime" > $vitals
        echo "Corrected ${vitals}:"
        cat  $vitals >> tcvitals.${anadate[1]}${hha}+${nymde}${hhe}
        \rm -f ${vitals}.tmp
     end
                                           zeit_ci.x vtrack2
     vtrack -trktyp FV5 -fcst -freq $VTRKFRQF -fcsthrs $adjust_fcsthrs -rc $FVWORK/vtrack.rc $anadate[1] $anadate[2] $EXPID
                                           zeit_co.x vtrack2
#    Tag tcvitals for distribution
#    -----------------------------   
     /bin/mv tcvitals.${anadate[1]}${hha}+${nymde}${hhe} ${EXPID}.tcvitals.${nymd1g}${hh1g}+${nymde}${hhe}.txt

  endif  # doing vortex tracking

                              # Last line of SingleExecVortexTrackerRun_()
\end


#.............................................................................

# ------------------------------
  Sub CoupleGcmToAna_( nymd_g2a_, nhms_g2a_, Viter_ )
# ------------------------------
  if ( $?ECHO___ ) set echo

        set nymd_g2a_ = $nymd_g2a_
        set nhms_g2a_ = $nhms_g2a_

#       Define main I/O files for analysis
#       ----------------------------------
        set sfcfile  = `echorc.x -template $EXPID $nymd_g2a_ $nhms_g2a_ surface_bkg_filename`
        set bkgfile  = `echorc.x -template $EXPID $nymd_g2a_ $nhms_g2a_ upper-air_bkg_filename`

#       Build initial trajectory
#       ------------------------

        set bkg_dateb  = `tick $nymd_g2a_ $nhms_g2a_ -$bkgbits0_sec`
        set bkg_datee  = `tick $nymd_g2a_ $nhms_g2a_  $varwindow_sec`

        @   bkg_dtsec  = $ASYNBKG * 60

#_RT    set trajfile = `echorc.x -template $EXPID $bkg_dateb[1] $bkg_dateb[2] upalcv_traj_filename`
#       if ( -e $trajfile ) then
#             rs52dyn.x -dynrst  fvcore_internal_rst \
#                       -moistrst moist_internal_rst \
#                       -ana      $trajfile          \
#                       -trajout  $trajfile          \
#                       -expid    $EXPID \
#                       -nymd     $bkg_dateb[1] -nhms $bkg_dateb[2]
#       endif

#_RT    if ( $DO4DVAR ) exit 0  # Bypass shuffling of bkg files for now

#       Build list of bkg filenames within this assimilation cycle
#       ----------------------------------------------------------

        set sfcbkg_lst    = ""
        set upabkg_lst    = ""
        set bkgsfc_lst    = ""
        set bkgupa_lst    = ""
        set cbkg_lst      = ""
        set chembkg_lst   = ""
        set abkg_lst      = ""
        set bkgsfcrst_lst = ""
        set bkguparst_lst = ""
        set abkgetarst_lst = ""
        set cbkgetarst_lst = ""
        set gaasbkg_lst    = ""
        set gaasbkgrst_lst = ""
        set nbkg = 0
        @ bkgbits = $bkgbits0
        if ( ! $DO4DVAR ) then
          while ( $bkgbits <= $bkgbitsf )

             set fhr  = `echo $bkgbits |awk '{printf "%02d", $1}'`

             set myname  = `echorc.x -template $EXPID $bkg_dateb[1] $bkg_dateb[2] sfcrst_bkg${fhr}_filename`
             set bkgsfcrst_lst = ( $bkgsfcrst_lst $myname )

             set myname  = `echorc.x -template $EXPID $bkg_dateb[1] $bkg_dateb[2] uparst_bkg${fhr}_filename`
             set bkguparst_lst = ( $bkguparst_lst $myname )

             set myname  = `echorc.x -template $EXPID $bkg_dateb[1] $bkg_dateb[2] aerorst_bkg${fhr}_filename`
             set abkgetarst_lst   = ( $abkgetarst_lst   $myname ) 

             set myname  = `echorc.x -template $EXPID $bkg_dateb[1] $bkg_dateb[2] chemrst_bkg${fhr}_filename`
             set cbkgetarst_lst   = ( $cbkgetarst_lst   $myname ) 

             set myname  = `echorc.x -template $EXPID $bkg_dateb[1] $bkg_dateb[2] surface_bkg_filename`
             set sfcbkg_lst = ( $sfcbkg_lst $myname )

             set myname  = `echorc.x -template $EXPID $bkg_dateb[1] $bkg_dateb[2] upper-air_bkg_filename`
             set upabkg_lst = ( $upabkg_lst $myname )

             set myname  = `echorc.x -template $EXPID $bkg_dateb[1] $bkg_dateb[2] surface_bkg${fhr}_filename`
             set bkgsfc_lst = ( $bkgsfc_lst $myname )

             set myname  = `echorc.x -template $EXPID $bkg_dateb[1] $bkg_dateb[2] upper-air_bkg${fhr}_filename`
             set bkgupa_lst = ( $bkgupa_lst $myname )

             set myname  = `echorc.x -template $EXPID $bkg_dateb[1] $bkg_dateb[2] chem_bkg${fhr}_filename`
             set chembkg_lst = ( $chembkg_lst $myname )

             set myname  = `echorc.x -template $EXPID $bkg_dateb[1] $bkg_dateb[2] aero_bkg_filename`
             set abkg_lst   = ( $abkg_lst   $myname ) 

             set myname  = `echorc.x -template $EXPID $bkg_dateb[1] $bkg_dateb[2] chem_bkg_filename`
             set cbkg_lst   = ( $cbkg_lst   $myname ) 

             if ($bkgbits != $bkgbits0) then
                 set myname  = `echorc.x -template $EXPID $bkg_dateb[1] $bkg_dateb[2] gaas_bkg_filename`
                 set gaasbkg_lst    = ( $gaasbkg_lst    $myname ) 

                 set myname  = `echorc.x -template $EXPID $bkg_dateb[1] $bkg_dateb[2] gaasrst_bkg_filename`
                 set gaasbkgrst_lst = ( $gaasbkgrst_lst $myname ) 
             endif

          set bkg_dateb  = `tick $bkg_dateb[1] $bkg_dateb[2] $bkg_dtsec`
          @ bkgbits = $bkgbits + $dtasyn_hrs;
          @ nbkg++

          end # < while (nbkg) >

        endif # < DO4DVAR >
        wait
        set bkg_dateb  = `tick $bkg_dateb[1] $bkg_dateb[2] -$bkg_dtsec` # store date/time of last bkg files within this cycle

#       Save the last bkgsfc output within this cycle so it doesn't get overwritten
#       ---------------------------------------------------------------------------
        if ( $ASYNBKG != 360 ) then

           if ( ! $DO4DVAR ) then

              set bkg_nymdl = $bkg_dateb[1]
              set bkg_nhmsl = $bkg_dateb[2]

              set vtxp3   = `echorc.x -template $EXPID $bkg_nymdl $bkg_nhmsl upper-air_vtx_filename`
              set vtx09   = `echorc.x -template $EXPID $bkg_nymdl $bkg_nhmsl upper-air_vtx09_filename`
              if ( -e $vtxp3 ) /bin/cp $vtxp3 $vtx09  &

              set sfcp3   = `echorc.x -template $EXPID $bkg_nymdl $bkg_nhmsl surface_bkg_filename`
              /bin/cp $sfcp3 $bkgsfc_lst[$nbkg]  &

              set bkgp3   = `echorc.x -template $EXPID $bkg_nymdl $bkg_nhmsl upper-air_bkg_filename`
              /bin/cp $bkgp3 $bkgupa_lst[$nbkg] &

              set cbkgp3   = `echorc.x -template $EXPID $bkg_nymdl $bkg_nhmsl chem_bkg_filename`
              /bin/cp $cbkgp3 $chembkg_lst[$nbkg] &

            endif
         endif # < asynbkg >
         wait

         exit 0

                              # Last line of CoupleGcmToAna_()
\end

#.............................................................................
# -----------------------------------
  Sub SaveRstForFcst_()
# -----------------------------------
  if ( $?ECHO___ ) set echo

#        Store intermediate restarts for later forecasts 
#        -----------------------------------------------
         if ( $VAROFFSET ) then
           if ( ! `grep -c "@" saverst.rc` ) then

              set saverst   = `cat saverst.rc`

              # Determine date/time of available checkpoint files
              # and which are to be saved ...
              # -------------------------------------------------
              set chkpfiles = `ls fvcore_internal_checkpoint.*`
              set nymd_chkpnt = ""
              set   hh_chkpnt = ""
              @ nchkpnt = 0
              foreach  fn ( $chkpfiles ) 
                 set d_chkpnt = `echo $fn | cut -d. -f2- | cut -c1-8`
                 set h_chkpnt = `echo $fn | cut -d. -f2- | cut -c10-11`
                 foreach hr ( $saverst ) 
                    if( $hr == $h_chkpnt ) then
                       set nymd_chkpnt = ( $nymd_chkpnt $d_chkpnt )
                       set   hh_chkpnt = (   $hh_chkpnt $h_chkpnt )
                       @ nchkpnt++
                    endif
                 end
              end

              set grs_list = ( `grs_list.pl -rc AGCM.rc` )
              @ n = 1
              while ( $n <= $nchkpnt )
                 set nymd_sv = $nymd_chkpnt[$n]
                 set   hh_sv =   $hh_chkpnt[$n]
# Clean up any existing arc files
                 /bin/rm stage4fcst.arc
                 /bin/rm stage4ecmwf.arc
                 /bin/rm stage4g5ncep.arc

# Touch new arc files for writing
                 touch stage4fcst.arc
                 touch stage4ecmwf.arc
                 touch stage4g5ncep.arc

                 if ( ( $nymd_sv == $wrt_rst_nymd ) && ( $hh_sv == $wrt_rst_hr ) ) then # special handle for IAU file
                    set cmd = /bin/cp  # in this case, cannot move files since they are needed as rsts for next cycle
                 else
                    set cmd = /bin/mv
                 endif
                 if ( ( "$STAGE4FCST" == "/dev/null" ) && ( "$STAGE4ECMWF" == "/dev/null"  ) && ( "$STAGE4G5NCEP" == "/dev/null"  ) ) then
                    echo "env var STAGE4FCST, STAGE4G5NCEP or STAGE4ECMWF needs to be defined to allow stage of restarts"
                    echo "        Restart files not staged "
                    break
                 else
                    if ( $DOIAU || $DO4DVAR ) then
                         foreach rs ( $grs_list )
                           $cmd ${rs}_checkpoint.${nymd_sv}_${hh_sv}00z.$RSTSUFFIX $EXPID.${rs}_rst.${nymd_sv}_${hh_sv}z.$RSTSUFFIX &
                           if ( $status ) set do_mkrst = 0
                           echo "$STAGE4FCST/$EXPID.${rs}_rst.${nymd_sv}_${hh_sv}z.$RSTSUFFIX" >> stage4fcst.arc
                           echo "$STAGE4ECMWF/$EXPID.${rs}_rst.${nymd_sv}_${hh_sv}z.$RSTSUFFIX" >> stage4ecmwf.arc
                           echo "$STAGE4G5NCEP/$EXPID.${rs}_rst.${nymd_sv}_${hh_sv}z.$RSTSUFFIX" >> stage4g5ncep.arc
                         end
#_RT                     if ( ( $nymd_sv == $wrt_rst_nymd ) && ( $hh_sv == $wrt_rst_hr ) ) then # special handle for IAU file
#_RT                        $cmd agcm_import_rst $EXPID.agcm_import_rst.${nymd_sv}_${hh_sv}z.$RSTSUFFIX &
#_RT                        if ( $status ) set do_mkrst = 0
#_RT                        echo "$STAGE4FCST/$EXPID.agcm_import_rst.${nymd_sv}_${hh_sv}z.$RSTSUFFIX" >> stage4fcst.arc
#_RT                     endif
                         wait
                    else
                         foreach rs ( $grs_list )
                           $cmd ${rs}_rst $EXPID.${rs}_rst.${nymd_sv}_${hh_sv}z.$RSTSUFFIX &
                           echo "$STAGE4FCST/$EXPID.${rs}_rst.${nymd_sv}_${hh_sv}z.$RSTSUFFIX" >> stage4fcst.arc
                           echo "$STAGE4ECMWF/$EXPID.${rs}_rst.${nymd_sv}_${hh_sv}z.$RSTSUFFIX" >> stage4ecmwf.arc
                           echo "$STAGE4G5NCEP/$EXPID.${rs}_rst.${nymd_sv}_${hh_sv}z.$RSTSUFFIX" >> stage4g5ncep.arc
                         end
                         wait
                    endif
                    if ( -e biasinp.$RSTSUFFIX ) then 
                        $cmd -f biasinp.$RSTSUFFIX $EXPID.biasinp_rst.${nymd_sv}_${hh_sv}z.$RSTSUFFIX
                        echo "$STAGE4FCST/$EXPID.biasinp_rst.${nymd_sv}_${hh_sv}z.$RSTSUFFIX" stage4fcst.arc 
                    endif
                    if ( -e biasinp.ctl ) then
                        $cmd -f biasinp.ctl $EXPID.biasinp_rst.${nymd_sv}_${hh_sv}z.ctl
                        echo "$STAGE4FCST/$EXPID.biasinp_rst.${nymd_sv}_${hh_sv}z.ctl" >> stage4fcst.arc
                    endif
                    if ( ( ! -e $EXPID.rst.lcv.${nymd_sv}_${hh_sv}z.bin ) && ( -e $EXPID.fvcore_internal_rst.${nymd_sv}_${hh_sv}z.$RSTSUFFIX ) ) \
                         mkdrstdate.x ${nymd_sv} ${hh_sv}0000 $EXPID.rst.lcv.${nymd_sv}_${hh_sv}z.bin
                    echo "$STAGE4FCST/$EXPID.rst.lcv.${nymd_sv}_${hh_sv}z.bin" >> stage4fcst.arc
                    echo "$STAGE4ECMWF/$EXPID.rst.lcv.${nymd_sv}_${hh_sv}z.bin" >> stage4ecmwf.arc
                    echo "$STAGE4G5NCEP/$EXPID.rst.lcv.${nymd_sv}_${hh_sv}z.bin" >> stage4g5ncep.arc
                    @ n++
                 endif # < STAGE4FCST >
              end  # < while >

#             Move rst files to forecast staging area
#             ----------------------------------------
              @ pesto_status = 0
              if ( ( "$STAGE4FCST" != "/dev/null" )  && ( -e stage4fcst.arc ) ) then
                   setenv PESTOROOT $STAGE4FCST
                   pesto -verbose -d $FVWORK -arc stage4fcst.arc
                   @ pesto_status = $status
              endif
              if ( ( "$STAGE4ECMWF" != "/dev/null" ) && ( -e stage4ecmwf.arc ) ) then
                   setenv PESTOROOT $STAGE4ECMWF
                   pesto -verbose -d $FVWORK -arc stage4ecmwf.arc
                   @ pesto_status += $status
              endif
              if ( ( "$STAGE4G5NCEP" != "/dev/null" ) && ( -e stage4g5ncep.arc ) ) then
                   setenv PESTOROOT $STAGE4G5NCEP
                   pesto -verbose -d $FVWORK -arc stage4g5ncep.arc
                   @ pesto_status += $status
              endif
              # Halt if pesto fails
              # -------------------
              if ( $pesto_status ) then
                   echo " Trouble in SaveRstForFcst_: pesto failed"
                   exit 1
              endif

           endif  # < -e saverst.rc >
         endif  # < varoffset >

         exit 0

                              # Last line of SaveRstForFcst_()
\end

#.............................................................................

# -----------------------------------
  Sub SplitExecPostProcessing_()
# -----------------------------------
  if ( $?ECHO___ ) set echo

# conversion and subsetting of outputs
# --------------------------------------------
  if ($CONVUPA) then

    if (`uname -n` =~ borg*) then

       # number of mpi processes should equal number of args to cnv2prs.pl
       #------------------------------------------------------------------
       #prund.pl -H $HOSTNAME -d etaana etabkg etaasm sfc diag &
       #esma_mpirun -np 5 $FVROOT/bin/prund.pl -H $HOSTNAME env NCPUS=$NCPUS FVROOT=$FVROOT FVHOME=$FVHOME $FVROOT/bin/cnv2prs.pl -%s
       cnv2prs.pl -etaana -etabkg -etaasm -sfc -diag

    else if (`uname -n` =~ r[0-9]*i[0-9]*n[0-9]*) then # pleiades

       # number of mpi processes should equal number of args to cnv2prs.pl
       #------------------------------------------------------------------
       prund.pl -H $HOSTNAME -d etaana etabkg etaasm sfc diag &
       esma_mpirun -perhost 1 -np 5 $FVROOT/bin/prund.pl -H $HOSTNAME env NCPUS=$NCPUS FVROOT=$FVROOT FVHOME=$FVHOME $FVROOT/bin/cnv2prs.pl -%s

    else # Altix

       cnv2prs.pl -etaana -etabkg -etaasm sfc -diag

    endif

  endif
  if ($CONVSFC) then
      cnv2prs.pl -dsfc
  endif
  if ($CONVPROG)   then  # this is used when extending background integration to mid-range forecast
      cnv2prs.pl -prog
  endif

  if ( -d $FVHOME/run/mom )   then  # this needs revision
      set GcmBegDate = $GcmBegEpoch[1]
      set GcmBegTime = $GcmBegEpoch[2]
      set GcmEndDate = $GcmEndEpoch[1]
      set GcmEndTime = $GcmEndEpoch[2]
      mom6diag.csh $EXPID $GcmBegDate $GcmBegTime $GcmEndDate $GcmEndTime
      if ( $status ) then
         echo " Trouble in SplitExecPostProcessing_(mom6diag) aborting ..."
         exit 1
      endif
  endif

  exit 0

                              # Last line of SplitExecPostProcessing_()
\end

#.............................................................................

# -------------------------
  Sub Stage4AdjointTools_()
# -------------------------
  if ( $?ECHO___ ) set echo

     if( ! -e stage4fsens.arc ) exit 0  # if so, store trajectory; postpone adjoint run for later
     if( !($?FcsBegEpoch) ) exit 0
     if( !($?FcsEndEpoch) ) exit 0

     # Move trajectory files to staging area
     # -------------------------------------
     @ pesto_status = 0
     if ( ($?STAGE4FSENS) ) then
          setenv PESTOROOT $STAGE4FSENS/s4fsens.$FcsBegEpoch[1]_$FcsBegEpoch[2]+$FcsEndEpoch[1]_$FcsEndEpoch[2]

          # Check for presence of trajectory (file time slot)
          # -------------------------------------------------
          set ftrajtmpl = `grep traj.lcv stage4fsens.arc`
          set tfile = `echorc.x -template $EXPID $TrjEndEpoch[1] $TrjEndEpoch[2] -fill $ftrajtmpl`
          set ftraj = `echorc.x -template $EXPID $TrjEndEpoch[1] $TrjEndEpoch[2] upalcv_traj_filename`
          set mtraj = `echorc.x -template $EXPID $TrjEndEpoch[1] $TrjEndEpoch[2] upalcv_mtrj_filename`
          set pfile = `echorc.x -template $EXPID $TrjEndEpoch[1] $TrjEndEpoch[2] upper-air_prog_filename` 
          set  hhmn = `echo $TrjEndEpoch[2] | cut -c1-4`
          set xfile = `ls -1 $EXPID.prog.eta.????????_??z+${TrjEndEpoch[1]}_${hhmn}z.$NCSUFFIX`
          if (! -e $xfile ) set xfile = `ls -1 $EXPID.prog.eta.${TrjEndEpoch[1]}_${hhmn}z.$NCSUFFIX`
          if ( -e $xfile ) then
              /bin/cp $xfile $pfile
          else
             echo " prog file $xfile not found"
             exit 1
          endif

          if ( -e $ftraj ) then
              # strip off analysis filename template from arc file
              # --------------------------------------------------
              if (-e xxxtraj.arc ) /bin/rm xxxtraj.arc
              grep -v ana.eta stage4fsens.arc | cat > xxxtraj.arc
              pesto -verbose -d $FVWORK -arc xxxtraj.arc -l
              @ pesto_status = $status
          else
              echo " No trajectory available for staging at this time "
          endif
     else
          echo " Env Var STAGE4FSENS not defined"
          @ pesto_status = 2
     endif
     # Halt if pesto fails
     # -------------------
     if ( $pesto_status ) then
          echo " Trouble in Stage4FSens_: pesto failed"
          exit 1
     endif

                              # Last line of Stage4AdjointTools_()
\end
#.............................................................................

# ------------------------------
  Sub AdjointToolsRun_()
# ------------------------------
  if ( $?ECHO___ ) set echo

    if( -e stage4fsens.arc ) exit 0  # postpone adjoint run for later

    if (-e fvsvec.rc || -e initadj.rc || -e oseledec.rc) then   # invoke only when .rc file is present
           set iamhere = `pwd`

#          Calculate singular vectors
#          --------------------------
           if (-e fvsvec.rc && -e fvsvec.ccmrun.namelist.tmpl) then

                                            zeit_ci.x fvsvec
             fvsvec $iamhere $EXPID $fcst_end[1] $fcst_end[2] $nsecs
                     set pert_status = $status
                                            zeit_co.x fvsvec
             if ( ${pert_status} ) then
                 Call AbnormalExit_( 2 )
             endif
           endif 
                                                                                                             
#          Calculate sensitivity
#          ---------------------
           if( -e CAP_apert.rc.tmpl ) then
              set rundt = `grep "^HEARTBEAT_DT:" CAP_apert.rc.tmpl | cut -d: -f2`
           else
              set rundt = `grep "^HEARTBEAT_DT:" CAP.rc.tmpl       | cut -d: -f2`
           endif

           set thisrc = fvsens.ccmrun.namelist.tmpl 
           set     hh = `echo ${FcsBegEpoch[2]} | cut -c1-2`
           if (-e fvsens.ccmrun.namelist_${hh}.tmpl) set thisrc = fvsens.ccmrun.namelist_${hh}.tmpl
           if (-e initadj.rc && -e $thisrc) then

                                           zeit_ci.x fvsens
             fvsens $iamhere $EXPID $fcst_end[1] $fcst_end[2] $hh $rundt
             set pert_status = $status
                                           zeit_co.x fvsens
             if ( ${pert_status} ) then
                 Call AbnormalExit_( 2 )
             endif
           endif

#          Calculate completementary sensitivity
#          -------------------------------------
           if (-e oseledec.rc && -e fvoseledec.ccmrun.namelist.tmpl) then

                                            zeit_ci.x fvoseledec
             fvoseledec $iamhere $EXPID $fcst_end[1] $fcst_end[2] $nsecs
             set pert_status = $status
                                            zeit_co.x fvoseledec
             if ( ${pert_status} ) then
                 Call AbnormalExit_( 2 )
             endif
           endif

    endif # < svec sens >

  exit 0

                              # Last line of AdjointToolsRun_()
\end

#.............................................................................

# ------------------------------
  Sub Diag2ODSRun_( Viter_, Final_ )
# ------------------------------
  if ( $?ECHO___ ) set echo

  if ( ! ($DOING_ANA && $DIAG2ODS) ) exit 0

  if ( $DO4DVAR && $Final_ ) exit 0

  if ( ! $FORECAST ) then

   if ( ($?NCPUS) ) then
     @ nproc = $NCPUS / 4
     if ($nproc < 1 ) set nproc = 1
   else
     set nproc = 1
   endif
   set hh = `echo $nhmsb | cut -c1-2`

                                         zeit_ci.x diag2ods

   diag2ods -rc $FVWORK/odsmatch.rc -ncpus $nproc -log $EXPID.ods.log.${nymdb}_${hh}z.txt $nymdb $nhmsb $EXPID

                                         zeit_co.x diag2ods

  if ( $DO_0HR_IMP ) then
     obimp_summary.pl $nymdb $nhmsb
  endif

   # This is largely a temporary solution to handling ODS and DIAG files
   # in the present configuration of a multi-loop 4dEnVar case
   if ( $Viter_ < 0 ) exit 0

   if ( $DO4DVAR && ($HYBRIDGSI != "/dev/null") ) then
      mkdir $EXPID.gsidiags.${nymdb}_${hh}z.iter$Viter_
      /bin/mv $EXPID.*diag*ges*bin $EXPID.gsidiags.${nymdb}_${hh}z.iter$Viter_
      /bin/mv $EXPID.*diag*anl*bin $EXPID.gsidiags.${nymdb}_${hh}z.iter$Viter_
      /bin/mv $EXPID.*diag*ods     $EXPID.gsidiags.${nymdb}_${hh}z.iter$Viter_
      tar -cvf $EXPID.gsidiags.${nymdb}_${hh}z.iter$Viter_.tar $EXPID.gsidiags.${nymdb}_${hh}z.iter$Viter_
   endif

  endif

  exit 0

                              # Last line of Diag2ODSRun_()
\end

#.............................................................................

# -----------------------------------
  Sub Geos5NcepPostProcessing_()
# -----------------------------------
  if ( $?ECHO___ ) set echo

#  Move checkpoint files into restart files 
#  (this will fail for d_rst ... it's ok)
#  ----------------------------------------
        /bin/rm d_rst
        set rst_tag = "${recdate[1]}_`echo ${recdate[2]} | cut -c1-2`z.bin"
        set chk_tag = "${recdate[1]}_`echo ${recdate[2]} | cut -c1-4`z.bin"
        foreach rs ( $grs_list )
             /bin/mv  ${rs}_checkpoint.${chk_tag}  $EXPID.${rs}_rst.${rst_tag}
        end
        if( $#grs_list > 0 ) mkdrstdate.x ${recdate[1]} ${recdate[2]}  $EXPID.rst.lcv.${rst_tag}

  exit 0

                              # Last line of Geos5NcepPostProcessing_()
\end

#.............................................................................

# -----------------------------------
  Sub Geos5SaveFcstRestart_()
# -----------------------------------
  if ( $?ECHO___ ) set echo

# Check for existence of checkpoint files
# ---------------------------------------
  set checkpoint_files = ( `ls *_checkpoint*` )
  if ($#checkpoint_files == 0) exit 0

# Move checkpoint files into restart files 
# ----------------------------------------
  set recdate = `grep RECORD_REF_DATE AGCM.rc | grep -v "#" | cut -d: -f2`
  set rectime = `grep RECORD_REF_TIME AGCM.rc | grep -v "#" | cut -d: -f2`
  /bin/rm d_rst
  set rst_tag = "${recdate[1]}_`echo ${rectime[1]} | cut -c1-2`z.$RSTSUFFIX"
  set chk_tag = "${recdate[1]}_`echo ${rectime[1]} | cut -c1-4`z.$RSTSUFFIX"
  set grs_list = ( `grs_list.pl -rc AGCM.rc` )
  foreach rs ( $grs_list )
       /bin/mv  ${rs}_checkpoint.${chk_tag}  $EXPID.${rs}_rst.${rst_tag}
  end
  if( $#grs_list > 0 ) mkdrstdate.x ${recdate[1]} ${rectime[1]}  $EXPID.rst.lcv.${rst_tag}

  exit 0

                              # Last line of Geos5SaveFcstRestart_()
\end

#.............................................................................

# ---------------------------------------
  Sub TagAndCopyStraightForecastOutput_( Final_ )
# ---------------------------------------
  if ( $?ECHO___ ) set echo

  if ( ! $Final_ ) exit 0

# Check for HREPACK and wait for it to finish
# -------------------------------------------
   if ( ( $DOFREPACK ) && ( ! -e ./EGRESS_HREPACK ) ) then 
         @ waitcounter = 0
                            zeit_ci.x frepack
         while ( ( ! -e ./EGRESS_HREPACK ) && ( $waitcounter < $HREPACK_WAIT ) )
            sleep 60
            @ waitcounter ++
         end
                            zeit_co.x  frepack
        if  ( ! -e ./EGRESS_HREPACK ) exit 88
   endif

   set progson = 0
   set trigger = "+."
   set list = ( `/bin/ls *${trigger}*${NCSUFFIX}` )
   if ( $#list ) then
       set progson = 1
       set hfile = "TMPLHIST.rc"
       if( -e ./$hfile ) /bin/rm ./$hfile
       grep template ./HISTORY.rc > ./$hfile
   endif

# Forecasting files need extra tagging for archiving
# --------------------------------------------------
  if ( $progson ) then

     set hh = `echo $gcm_nhms0 | cut -c1-2`
     set this_itime = ${gcm_nymd0}_${hh}z

# Get file names from TMPLHIST.rc
# -------------------------------

     set    allftypes = ( $list )
     foreach ftype ( $allftypes )
        set files = $ftype
        if ( !($status) ) then        # at least 1 file of this type
           foreach file ( $files )
# -- Special handling for repacked files    
              if ( ( $file =~ *.fana.eta.* ) || ( $file =~ *.${this_itime}+* ) ) then
                   echo "not renaming $file"
              else
                   set vtime = $file:r  # verification time
                   set vtime = $vtime:e # verification time
                   set bname = $file:r  # base name $expid.prog.eta
                   set bname = $bname:r # base name $expid.prog.eta
                   set bname = $bname:r # base name $expid.prog.eta
                   set nname = "$bname.$this_itime+$vtime.$NCSUFFIX"
                   /bin/mv $file $nname
              endif
           end
        endif
     end
     wait

#    If so, copy gradient vectors for later analysis sensitivity runs
#    ----------------------------------------------------------------
     if ( $grsv ) then
          set grfiles = `ls *fsens_*.eta* *fsensainc_*.eta*`
          foreach grfile ( $grfiles )
                set vtime = $grfile:r # verification time
                set vtime = $vtime:e  # verification time
                set bname = $grfile:r # base name $expid.prog.eta
                set bname = $bname:r  # base name $expid.prog.eta
                set nname = "$bname.$this_itime+$vtime.$NCSUFFIX"
                /bin/mv -f $grfile $nname
                /bin/cp -f $nname  $grstage &
          end
     endif
     wait

#    convert prog.eta output with lcv2prs.x program
#    ----------------------------------------------
     if ($CONVPROG)   then
                                         zeit_ci.x cnv2prs
        cnv2prs.pl -prog
                                         zeit_co.x cnv2prs
     endif

  endif

  exit 0

                              # Last line of TagAndCopyStraightForecastOutput_()
\end
#.............................................................................

# ------------------------------------
  Sub SignalEndOfDasCycle_( ANA_ymd_, ANA_hms_ )
# ------------------------------------
  if ( $?ECHO___ ) set echo

  set ANA_hr = `echo $ANA_hms_ | cut -c1-2`
  touch $FVHOME/.DONE_CENTRAL_ADAS.$ANA_ymd_$ANA_hr

                              # Last line of SignalEndOfDasCycle_()
\end
#.............................................................................

# ------------------------------------
  Sub TagAndCopyForecastOutput_()
# ------------------------------------
  if ( $?ECHO___ ) set echo

  if (( "$STAGE4FCST" != "/dev/null" ) && ( ! `grep -c "@" saverst.rc` )) then
       set fcst_times = `cat saverst.rc`
       set grs_list = ( `grs_list.pl -rc AGCM.rc` )
       foreach ftime ( $fcst_times )
           set agcm_import = ""
           if ( ( $AGCMFCST ) && ( $ftime % 2 ) ) set agcm_import =  "agcm_import"
           /bin/cp -f $EXPID.rst.lcv.*_${ftime}z.bin $fcstage &
           /bin/cp -f $EXPID.traj_lcv_rst.????????_${ftime}00z.$NCSUFFIX $fcstage &
#          /bin/cp -f $EXPID.mtrj_lcv_rst.????????_${ftime}00z.$NCSUFFIX $fcstage &
#          /bin/cp -f $EXPID.ptrj_prs_rst.????????_${ftime}00z.$NCSUFFIX $fcstage &
           foreach restart ( $grs_list biasinp $agcm_import )
              /bin/cp -f $EXPID.${restart}_rst.????????_${ftime}z.??? $fcstage &
           end
       end
       /bin/ls -l $fcstage
       wait
  endif

# Check for HREPACK and wait for it to finish
# -------------------------------------------
   if ( ( $DOFREPACK ) && ( ! -e ./EGRESS_HREPACK ) ) then
         @ waitcounter = 0
                                       zeit_ci.x  frepack
         while ( ( ! -e ./EGRESS_HREPACK ) && ( $waitcounter < $HREPACK_WAIT ) )
            sleep 60
            @ waitcounter ++
         end
                                       zeit_co.x  frepack
        if  ( ! -e ./EGRESS_HREPACK ) exit 88
   endif

# Forecasting files need extra tagging for archiving
# --------------------------------------------------
  if ( $FORECAST ) then
     set vortex = 0

# Get file names from HISTORY.rc
# ------------------------------

     set    allftypes = ( `read_HIST.csh ./HISTORY.rc`)
     foreach ftype ( $allftypes )
# -- Special handling for repacked files    
        set ftype = `echo $ftype | sed -e 's/_unz//'` 
        set files = `/bin/ls -1 ${ftype}*.$NCSUFFIX`
        if ( !($status) ) then        # at least 1 file of this type
           foreach file ( $files )
# -- Special handling for repacked files    
              if ( ( $file =~ *.fana.eta.* ) || ( $file =~ *.${itime}+* ) || ( $file =~ *+-* ) ) then
                   echo "not renaming $file"
              else
                   set vtime = $file:r  # verification time
                   set vtime = $vtime:e # verification time
                   set bname = $file:r  # base name $expid.prog.eta
                   set bname = $bname:r # base name $expid.prog.eta
                   set nname = "$bname.$itime+$vtime.$NCSUFFIX"
                   /bin/mv $file $nname
              endif
           end
        endif
     end
     wait

#    If so, copy gradient vectors for later analysis sensitivity runs
#    ----------------------------------------------------------------
     if ( $grsv ) then
          set grfiles = `ls *fsens_*.eta* *fsensainc_*.eta*`
          foreach grfile ( $grfiles )
                set vtime = $grfile:r # verification time
                set vtime = $vtime:e  # verification time
                set bname = $grfile:r # base name $expid.prog.eta
                set bname = $bname:r  # base name $expid.prog.eta
                set nname = "$bname.$itime+$vtime.$NCSUFFIX"
                /bin/mv -f $grfile $nname
                /bin/cp -f $nname  $grstage &
          end
     endif
     wait

#    convert prog.eta output with lcv2prs.x program
#    ----------------------------------------------
     if ($CONVPROG)   then
                                         zeit_ci.x cnv2prs
        cnv2prs.pl -prog
                                         zeit_co.x cnv2prs
     endif

  endif

  exit 0

                              # Last line of TagAndCopyForecastOutput_()
\end

#.............................................................................

# --------------------------------------
  Sub AdjointToolsPostProcessing_()
# --------------------------------------
  if ( $?ECHO___ ) set echo

# Initial- and final-time singular vector files
# ---------------------------------------------
  if ( -e fvsvec.rc || -e initadj.rc || -e oseledec.rc ) then
       foreach ftype ( isvec.eta fsvec.eta icnop.eta fcnop.eta )
            set files = `/bin/ls -1 $EXPID.$ftype*.$NCSUFFIX`
            if ( !($status) ) then        # at least 1 file of this type
               foreach file ( $files )
                  set vtime = $file:r  # verification time
                  set vtime = $vtime:r # verification time
                  set vtime = $vtime:e # verification time
                  set vtype = $file:r  # verification time
                  set vtype = $vtype:e # verification time
                  set bname = $file:r  # base name $expid.prog.eta
                  set bname = $bname:r # base name $expid.prog.eta
                  set bname = $bname:r # base name $expid.prog.eta
                  /bin/mv $file $bname.$itime+$vtime.$vtype.$NCSUFFIX
               end
            endif
       end
       foreach ftype ( Jgradf_ Jgradfainc_ )
          set files = `/bin/ls -1 $EXPID.${ftype}*.$NCSUFFIX`
          if ( !($status) ) then     # at least 1 file of this type
             foreach file ( $files )
                set vtime = $file:r  # verification time
                set vtime = $vtime:e # verification time
                set bname = $file:r  # base name $expid.prog.eta
                set bname = $bname:r # base name $expid.prog.eta
                /bin/mv $file $bname.$itime+$vtime.$NCSUFFIX
             end
          endif
       end
       foreach ftype ( itraj.lcv ftraj.lcv finc.eta )
            set files = `/bin/ls -1 $EXPID.$ftype*.$NCSUFFIX`
            if ( !($status) ) then        # at least 1 file of this type
               foreach file ( $files )
                  set vtime = $file:r  # verification time
                  set vtime = $vtime:e # verification time
                  set bname = $file:r  # base name $expid.prog.eta
                  set bname = $bname:r # base name $expid.prog.eta
                  /bin/mv $file $bname.$itime+$vtime.$NCSUFFIX
               end
            endif
       end
       foreach ftype ( Jnormf EMferrnorm Xdot )
          set files = `/bin/ls -1 $EXPID.${ftype}*.txt`
          if ( !($status) ) then     # at least 1 file of this type
             foreach file ( $files )
                set vtime = $file:r  # verification time
                set vtime = $vtime:e # verification time
                set bname = $file:r  # base name $expid.prog.eta
                set bname = $bname:r # base name $expid.prog.eta
                /bin/mv $file $bname.$itime+$vtime.txt
             end
          endif
       end
       if ( ! $grsv ) then
         foreach ftype ( fsens_ fsensainc_ EMferr_ )
            set files = `/bin/ls -1 $EXPID.$ftype*.$NCSUFFIX`
            if ( !($status) ) then        # at least 1 file of this type
               foreach file ( $files )
                  set vtime = $file:r  # verification time
                  set vtime = $vtime:e # verification time
                  set bname = $file:r  # base name $expid.prog.eta
                  set bname = $bname:r # base name $expid.prog.eta
                  /bin/mv $file $bname.$itime+$vtime.$NCSUFFIX
               end
            endif
         end
       endif
  endif

  exit 0

                              # Last line of AdjointToolsPostProcessing_()
\end

#.............................................................................

# ------------------------------------
  Sub InterimTag_()
# ------------------------------------
  if ( $?ECHO___ ) set echo
   if ( $INTTAG ) then
        set tag = `token_resolve %y4%m2%d2_%h2z $nymdb $nhmsb`
        /bin/mv -f fvpsas.log  $EXPID.gcm.log.${tag}.txt
        /bin/mv -f ana.log     $EXPID.ana.log.${tag}.txt
        /bin/mv -f obs.log     $EXPID.obs.log.${tag}.txt
        /bin/mv -f sobs.log    $EXPID.sobs.log.${tag}.txt
        /bin/mv -f ods.log     $EXPID.ods.log.${tag}.txt
        /bin/mv -f trak.log    $EXPID.trak.log.${tag}.txt
        /bin/mv -f vtx.log     $EXPID.vtx.log.${tag}.txt
        /bin/mv -f sana.log    $EXPID.sana.log.${tag}.txt
        /bin/mv -f cqc.log     $EXPID.cqc.log.${tag}.txt
        /bin/mv -f prepqc.log  $EXPID.prepqc.log.${tag}.txt
   
   endif

  exit 0

                              # Last line of InterimTag_()
\end

#.............................................................................

# ------------------------------------
  Sub FinalTaggingAndRecycling_()
# ------------------------------------
  if ( $?ECHO___ ) set echo

# ... Restarts/log/LSM(Forecast only)
#     ------------
  if ( $FORECAST ) then
       /bin/rm d_rst
       mkdrstdate.x $fcst_end    # create d_rst with current date and time
  endif

  set buf  = `rst_date d_rst`
  set nymd2 = ${buf[1]}
  set nhms2 = ${buf[2]}
  @ hour2 = $nhms2 / 10000
  @ hour4 = $nhms2 / 100
  set hour2 = `echo $hour2 |awk '{printf "%02d", $1}'`
  set hour4 = `echo $hour4 |awk '{printf "%04d", $1}'`
  set rtag  = ${nymd2}_${hour2}z
  set rtag4 = ${nymd2}_${hour4}z

  @ timeinc_sec = $TIMEINC * 60
  set buf  = (`rst_date d_rst`)
  set buf  = (`tick $buf -$timeinc_sec`) # back to start time of present cycle
  set nymd3 = ${buf[1]}
  set nhms3 = ${buf[2]}
  @ hour3 = $nhms3 / 10000
  set hour3 = `echo $hour3 |awk '{printf "%02d", $1}'`
  set rtag3  = ${nymd3}_${hour3}z

  if ( $FORECAST ) then
	set rtags = $itime+${nymd1}_${hour1}z-${nymd2}_${hour2}z
  else
	set rtags = ${nymd1}_${hour1}z-${nymd2}_${hour2}z
        mkdir -p       $FVHOME/recycle/hold
        setenv RSTHOLD $FVHOME/recycle/hold
        foreach rs ( $grs_list )
            if ( $rs == "agcm_import" || $rs == "aiau_import" ) continue
            if ( -e ${rs}_rst ) /bin/mv -f ${rs}_rst  $EXPID.${rs}_rst.$rtag.$RSTSUFFIX 
            /bin/cp $EXPID.${rs}_rst.$rtag.$RSTSUFFIX $RSTHOLD/ &
            if ( $final_fcst )   /bin/cp $EXPID.${rs}_rst.$rtag.$RSTSUFFIX ${fcstage}/ &
        end

        /bin/cp -f d_rst $EXPID.d_rst 
        /bin/mv -f d_rst $EXPID.rst.lcv.$rtag.bin 
        /bin/cp $EXPID.rst.lcv.$rtag.bin $RSTHOLD/ &
        if ( $final_fcst ) /bin/cp $EXPID.rst.lcv.$rtag.bin ${fcstage}/ &

        if ( $DOING_ANA ) then
	    foreach rs ( $ars_list )
             /bin/mv $rs  $EXPID.ana_${rs}_rst.$rtag.txt
             /bin/cp $EXPID.ana_${rs}_rst.$rtag.txt $RSTHOLD/ &
	    end
            if ( $ANGLEBC  && $DIAGTAR ) then
              /bin/mv radstat $EXPID.ana_radstat_rst.$rtag.tar
              /bin/cp $EXPID.ana_radstat_rst.$rtag.tar $RSTHOLD/ &
            endif

            # hold lfo files for the next segment of ldas coupling
            #----------------------------------------------------------
            if ( $LDAS_ANA ) then
               mkdir -p              $FVHOME/recycle/holdforc
               /bin/cp  *2d_lfo*nc4  $FVHOME/recycle/holdforc/
            endif

            # local copy to be moved by pesto, 2nd copy to be dealt w/ by recycle
            #--------------------------------------------------------------------
            if ( -e biasinp.$RSTSUFFIX ) then
                /bin/mv biasinp.$RSTSUFFIX $EXPID.biasinp.$rtag.$RSTSUFFIX
                /bin/cp $EXPID.biasinp.$rtag.$RSTSUFFIX $EXPID.biasinp_rst.$rtag.$RSTSUFFIX
                /bin/cp $EXPID.biasinp_rst.$rtag.$RSTSUFFIX $RSTHOLD/ &
            endif

            # local copy to be moved by pesto, 2nd copy to be dealt w/ by recycle
            #--------------------------------------------------------------------
            if ( -e biasinp.ctl ) then
                /bin/mv biasinp.ctl $EXPID.biasinp.$rtag.ctl
                /bin/cp $EXPID.biasinp.$rtag.ctl $EXPID.biasinp_rst.$rtag.ctl
                /bin/cp $EXPID.biasinp_rst.$rtag.ctl $RSTHOLD/ &
            endif
    
            # local copy to be moved by pesto, 2nd copy to be dealt w/ by recycle
            #--------------------------------------------------------------------
            if ( $DO4DVAR ) then                                        # initial traj needed for 4dvar
               if ( -e $EXPID.traj_lcv_rst.$rtag4.$NCSUFFIX ) then
                   /bin/cp $EXPID.traj_lcv_rst.$rtag4.$NCSUFFIX $RSTHOLD/$EXPID.traj_lcv_rst.$rtag4.$NCSUFFIX &
               else
                  if ( -e $EXPID.traj.lcv.$rtag4.$NCSUFFIX ) then
                      /bin/cp $EXPID.traj.lcv.$rtag4.$NCSUFFIX $EXPID.traj_lcv_rst.$rtag4.$NCSUFFIX &
                      /bin/cp $EXPID.traj.lcv.$rtag4.$NCSUFFIX $RSTHOLD/$EXPID.traj_lcv_rst.$rtag4.$NCSUFFIX &
                  endif
               endif
#              if ( -e $EXPID.ptrj.prs.$rtag4.$NCSUFFIX ) then
#                  /bin/cp $EXPID.ptrj.prs.$rtag4.$NCSUFFIX $EXPID.ptrj_prs_rst.$rtag4.$NCSUFFIX &
#                  /bin/cp $EXPID.ptrj.prs.$rtag4.$NCSUFFIX $RSTHOLD/$EXPID.ptrj_prs_rst.$rtag4.$NCSUFFIX &
#              endif
            endif


            set GDA_list  = `ls *GDA.all.*` 
            if ( ! $status ) then
                 set GDA_rst = `echo $GDA_list[$#GDA_list] | sed -e 's/\.all\./.rst./'`
                 /bin/cp $GDA_list[$#GDA_list] ./${GDA_rst}
                 if ( $?trksufx ) then
                      set tstsufx = `echo $GDA_rst | cut -d. -f5,6`
                      if ( "$tstsufx" == "$trksufx" ) /bin/rm -f $GDA_rst
                 endif
                 if ( -e $GDA_rst ) /bin/cp $GDA_rst $RSTHOLD/${GDA_rst}
            endif

            if ( $DO4DVAR ) then
    
                # local copy to be moved by pesto, 2nd copy to be dealt w/ by recycle
                #--------------------------------------------------------------------
                /bin/cp $EXPID.bkg.eta.$rtag.$NCSUFFIX $EXPID.bkg_eta_rst.$rtag.$NCSUFFIX &
                /bin/cp $EXPID.bkg.eta.$rtag.$NCSUFFIX $RSTHOLD/$EXPID.bkg_eta_rst.$rtag.$NCSUFFIX &
    
                /bin/cp $EXPID.cbkg.eta.$rtag.$NCSUFFIX $EXPID.cbkg_eta_rst.$rtag.$NCSUFFIX &
                /bin/cp $EXPID.cbkg.eta.$rtag.$NCSUFFIX $RSTHOLD/$EXPID.cbkg_eta_rst.$rtag.$NCSUFFIX &

                /bin/cp $EXPID.abkg.eta.$rtag.$NCSUFFIX $EXPID.abkg_eta_rst.$rtag.$NCSUFFIX &
                /bin/cp $EXPID.abkg.eta.$rtag.$NCSUFFIX $RSTHOLD/$EXPID.abkg_eta_rst.$rtag.$NCSUFFIX &

                /bin/cp $EXPID.bkg.sfc.$rtag.$NCSUFFIX $EXPID.bkg_sfc_rst.$rtag.$NCSUFFIX &
                /bin/cp $EXPID.bkg.sfc.$rtag.$NCSUFFIX $RSTHOLD/$EXPID.bkg_sfc_rst.$rtag.$NCSUFFIX &

            else

            # local copy to be moved by pesto, 2nd copy to be dealt w/ by recycle
            #--------------------------------------------------------------------
            @ n = 1
            while ( $n <= $nbkg )

               if ( -e $bkgsfc_lst[$n] ) then
                   /bin/cp    $bkgsfc_lst[$n]              $bkgsfcrst_lst[$n]  &
                   /bin/cp    $bkgsfc_lst[$n]     $RSTHOLD/$bkgsfcrst_lst[$n]  &
               else
                   /bin/cp    $sfcbkg_lst[$n]              $bkgsfcrst_lst[$n]  &
                   /bin/cp    $sfcbkg_lst[$n]     $RSTHOLD/$bkgsfcrst_lst[$n]  &
               endif

               if ( -e $bkgupa_lst[$n] ) then
                   /bin/cp    $bkgupa_lst[$n]              $bkguparst_lst[$n]  &
                   /bin/cp    $bkgupa_lst[$n]     $RSTHOLD/$bkguparst_lst[$n]  &
               else
                   /bin/cp    $upabkg_lst[$n]              $bkguparst_lst[$n]  &
                   /bin/cp    $upabkg_lst[$n]     $RSTHOLD/$bkguparst_lst[$n]  &
               endif

               if ( -e $cbkgetarst_lst[$n] ) then
                   /bin/cp    $cbkgetarst_lst[$n]          $cbkgetarst_lst[$n]  &
                   /bin/cp    $cbkgetarst_lst[$n] $RSTHOLD/$cbkgetarst_lst[$n]  &
               else
                   /bin/cp    $cbkg_lst[$n]                $cbkgetarst_lst[$n]  &
                   /bin/cp    $cbkg_lst[$n]       $RSTHOLD/$cbkgetarst_lst[$n]  &
               endif

               if ( -e $abkgetarst_lst[$n] ) then
                   /bin/cp    $abkgetarst_lst[$n]          $abkgetarst_lst[$n]  &
                   /bin/cp    $abkgetarst_lst[$n] $RSTHOLD/$abkgetarst_lst[$n]  &
               else
                   /bin/cp    $abkg_lst[$n]                $abkgetarst_lst[$n]  &
                   /bin/cp    $abkg_lst[$n]       $RSTHOLD/$abkgetarst_lst[$n]  &
               endif
               @ n++
               end
               wait

            endif # < DO4DVAR >

        endif # < DOING_ANA >

        set ctlfiles = `ls *vtx*.ctl`
        if ( $#ctlfiles > 0 ) then
          foreach ctl  ( $ctlfiles )
            set ctlnox = `ls $ctl | cut -d"." -f1-2`
            /bin/mv -f $ctl $ctlnox.$rtag.ctl
          end
        endif
        /bin/mv -f ana.log     $EXPID.ana.log.$rtags.txt
        /bin/mv -f obs.log     $EXPID.obs.log.$rtags.txt
        /bin/mv -f sobs.log    $EXPID.sobs.log.$rtags.txt
        /bin/mv -f trak.log    $EXPID.trak.log.$rtags.txt
        /bin/mv -f vtx.log     $EXPID.vtx.log.$rtags.txt
        /bin/mv -f ods.log     $EXPID.ods.log.$rtags.txt
        /bin/mv -f sana.log    $EXPID.sana.log.$rtags.txt
        /bin/mv -f cqc.log     $EXPID.cqc.log.$rtags.txt
        /bin/mv -f prepqc.log  $EXPID.prepqc.log.$rtags.txt

        if ( (! $DO4DVAR) ) then
           if ( $GAAS_ANA ) then
               @ n = 1
               @ nbkg = $#gaasbkg_lst
               while ( $n <= $nbkg )
                   if ( -e $gaasbkg_lst[$n] ) then
                       /bin/cp $gaasbkg_lst[$n]           $gaasbkgrst_lst[$n] &
                       /bin/cp $gaasbkg_lst[$n]  $RSTHOLD/$gaasbkgrst_lst[$n] &
                   endif
                   @ n++
               end
               wait
           endif
        endif

  endif

  /bin/mv -f fvpsas.log  $EXPID.gcm.log.$rtags.txt
  /bin/cp  .zeit  $EXPID.zeit.reg.$rtags.txt
  /bin/mv -f trak.log    $EXPID.trak.log.$rtags.txt

  if ( $MKRESRST ) then
       set rst_tag = "${itime}+${fcst_end[1]}_`echo ${fcst_end[2]} | cut -c1-2`z.$RSTSUFFIX"
       set chk_tag = "${fcst_end[1]}_`echo ${fcst_end[2]} | cut -c1-4`z.$RSTSUFFIX"

       mkdrstdate.x ${fcst_end} $EXPID.rst.lcv.${rst_tag}
       set grs_list = ( `grs_list.pl -rc AGCM.rc` )
       foreach rs ( $grs_list )
            if ( -e ${rs}_checkpoint.${chk_tag} ) then
                /bin/mv  ${rs}_checkpoint.${chk_tag}  $EXPID.${rs}_rst.${rst_tag}
            else 
                /bin/mv  ${rs}_checkpoint  $EXPID.${rs}_rst.${rst_tag} 
            endif
       end
       wait
  endif
  wait

  if ( ! $FORECAST ) then
    if ( $DO4DVAR ) then
       /bin/mv $EXPID.*rst*iter*.$RSTSUFFIX $FVHOME/recycle/hold
    endif
    if ( -d $FVHOME/run/mom ) then
       set momoutdir = `nmlread.py fvcore_layout.rc MOM_input_nml restart_output_dir`
       set mylcvs = (`ls -1 $EXPID.rst.lcv*`)
       set momtag = `echo $mylcvs[1] | cut -d. -f4`
       /bin/mv $momoutdir/MOM.res.nc $FVHOME/recycle/hold/$EXPID.mom_rst.${momtag}.nc4 
       foreach fn ( 1 2 3 )
         /bin/mv $momoutdir/MOM.res_${fn}.nc $FVHOME/recycle/hold/$EXPID.mom${fn}_rst.${momtag}.nc4 
       end
    endif
    cd $FVHOME/recycle/hold
    tar cvf $FVWORK/$EXPID.rst.${rtag}.tar $EXPID.* 
    /bin/mv $FVWORK/$EXPID.xinc*$NCSUFFIX .
    if ( ! $status ) then
       tar cvf $FVWORK/$EXPID.incrst.${rtag3}.tar $EXPID.xinc*$NCSUFFIX
       /bin/rm $EXPID.xinc*$NCSUFFIX
    endif
    if ( $DO4DVAR ) then
       /bin/rm $EXPID.*rst*iter*.$RSTSUFFIX
    endif
    cd -
    set lsttrajrst = `ls $EXPID.traj_lcv_rst.*$NCSUFFIX`
    if ( ${%lsttrajrst}  ) then
       tar cvf $FVWORK/$EXPID.trajrst.${rtag3}.tar $lsttrajrst
       /bin/rm $lsttrajrst
    endif
    if ( $DO4DIAU ) then
       set lstagcmrst = `ls $EXPID.agcm_import_rst.*$NCSUFFIX`
       if ( ${%lstagcmrst}  ) then
          tar cvf $FVWORK/$EXPID.agcmrst.${rtag3}.tar $lstagcmrst
          /bin/rm $lstagcmrst
       endif
    endif
  endif

  exit 0
                              # Last line of FinalTaggingAndRecycling_()
\end

#.............................................................................

# ------------------------------------
  Sub AbnormalExit_( _exitcode )
# ------------------------------------
  /bin/rm -f          ${FVHOME}/run/*.abnormal.log
  /bin/cp fvpsas.log  ${FVHOME}/run/fvpsas.abnormal.log
  /bin/cp ana.log     ${FVHOME}/run/ana.abnormal.log
  /bin/cp obs.log     ${FVHOME}/run/obs.abnormal.log
  /bin/cp sobs.log    ${FVHOME}/run/sobs.abnormal.log
  /bin/cp trak.log    ${FVHOME}/run/trak.abnormal.log
  /bin/cp vtx.log     ${FVHOME}/run/vtx.abnormal.log
  /bin/cp ods.log     ${FVHOME}/run/ods.abnormal.log
  /bin/cp sana.log    ${FVHOME}/run/sana.abnormal.log
  /bin/cp cqc.log     ${FVHOME}/run/cqc.abnormal.log
  /bin/cp prepqc.log  ${FVHOME}/run/prepqc.abnormal.log
  /bin/cp .zeit       ${FVHOME}/run/zeit.abnormal.log
  echo $myname": saving  abnormal logs to ${FVHOME}/run"
  echo $myname": abnormal exit from fvpsas, bye, bye..."

  exit $_exitcode
                              # Last line of AbnormalExit_()
\end
